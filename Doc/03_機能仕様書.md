# 機能仕様書（統合版）

各機能の詳細仕様を1ファイルに集約。元ファイルは Doc/archive/ に保存。

---

## 1. スタンプシステム

### 1.1 基本仕様

**スタンプ付与ルール:**
- 1回の来院 = 1個のスタンプ（基本ルール）
- 将来的に診療内容によって変更可能（現在は常に1個）

**スタッフ編集機能:**
- 目的: 誤登録の修正、テスト用途
- 制限: なし（何度でも編集可能）
- 監査証跡: すべての編集履歴を `stamp_history` に記録

### 1.2 データベース設計

**stamp_historyテーブル:**

| カラム名 | 型 | 説明 |
|---------|---|------|
| id | UUID | 主キー |
| user_id | TEXT | ユーザーID（profiles.id） |
| visit_date | TIMESTAMPTZ | 来院日時 |
| stamp_number | INTEGER | その時点でのスタンプ数（累積） |
| stamp_method | TEXT | 登録方法（'qr_scan' or 'manual_admin'） |
| qr_code_id | TEXT | QRコードID |
| notes | TEXT | メモ |
| created_at | TIMESTAMPTZ | 作成日時 |
| updated_at | TIMESTAMPTZ | 更新日時 |

**stamp_numberの意味（重要）:**

`stamp_number` は「その時点でのスタンプ数（累積）」を表す。

```
| visit_date | stamp_number | stamp_method | 説明 |
|-----------|--------------|--------------|------|
| 2月8日 09:00 | 1 | qr_scan | 1回目の来院 → スタンプ1個 |
| 2月9日 10:00 | 2 | qr_scan | 2回目の来院 → スタンプ2個 |
| 2月9日 10:30 | 5 | manual_admin | スタッフが「5個に設定」 |
| 2月9日 11:00 | 4 | manual_admin | スタッフが「4個に修正」 |
```

**訪問回数とスタンプ数の区別:**
- 訪問回数 = `stamp_history` テーブルのレコード数
- スタンプ数 = `MAX(stamp_number)` = `profiles.stamp_count`

### 1.3 トリガー関数: update_profile_stamp_count()

```sql
CREATE OR REPLACE FUNCTION update_profile_stamp_count()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE profiles
  SET
    stamp_count = (
      SELECT COALESCE(MAX(stamp_number), 0)
      FROM stamp_history
      WHERE user_id = NEW.user_id
    ),
    last_visit_date = (
      SELECT MAX(visit_date)
      FROM stamp_history
      WHERE user_id = NEW.user_id
    ),
    updated_at = NOW()
  WHERE id = NEW.user_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

`MAX(stamp_number)` を使用する理由: スタッフ編集でスタンプ数を自由に設定できるようにするため。`COUNT(*)` ではレコード数（訪問回数）しか取得できない。

### 1.4 API仕様

**POST /api/stamps（QRスキャン）:**
1. 現在のスタンプ数を取得（`profiles.stamp_count`）
2. 次のスタンプ数を計算（`currentStampCount + 1`）
3. `stamp_history` に新規レコードを挿入
4. トリガーで `profiles.stamp_count` が自動更新される

**重複チェック:** 同日同QRコードIDの組み合わせで重複防止

### 1.5 画面表示

**スタンプページ（/stamp）:**
- スタンプカウンター: `profiles.stamp_count` を表示
- 訪問回数: `stamp_history` のレコード数を表示
- 来院履歴リスト: 訪問回数、スタンプ数、スタッフ編集フラグ
- QRスキャンボタン

### 1.6 トラブルシューティング

| 症状 | 対処 |
|-----|------|
| スタンプ数が正しくない | トリガー関数が `MAX(stamp_number)` を使っているか確認 |
| 既存データが不正 | `UPDATE profiles SET stamp_count = (SELECT COALESCE(MAX(stamp_number), 0) FROM stamp_history WHERE user_id = profiles.id);` |
| 訪問回数とスタンプ数が混同 | 訪問回数=レコード数、スタンプ数=MAX(stamp_number) |

---

## 2. 特典交換システム

### 2.1 概要

貯まったスタンプで特典と交換できるシステム。患者の再来院モチベーション向上を目的とする。

**積み上げ式（v1.1で変更）:**
- スタンプは交換後も減らない
- 条件を満たせば何度でも交換可能
- 例: 20個貯まれば、5個/10個/15個/20個の特典すべて交換可能

### 2.2 データベース設計

**rewardsテーブル（特典マスター）:**

| カラム名 | 型 | 説明 |
|---------|---|------|
| id | UUID | 主キー |
| name | TEXT | 特典名 |
| description | TEXT | 詳細説明 |
| required_stamps | INTEGER | 必要なスタンプ数 |
| image_url | TEXT | 特典画像URL（オプション） |
| is_active | BOOLEAN | 有効/無効 |
| display_order | INTEGER | 表示順序 |
| created_at | TIMESTAMPTZ | 作成日時 |
| updated_at | TIMESTAMPTZ | 更新日時 |

**初期特典データ:**

| 特典名 | 必要スタンプ | 内容 |
|-------|-----------|------|
| オリジナル歯ブラシセット | 5個 | 歯ブラシ + 歯磨き粉 |
| フッ素塗布1回無料券 | 10個 | 通常\1,100 → 無料（有効期限6ヶ月） |
| 歯のクリーニング50%OFF券 | 15個 | 通常\5,500 → \2,750（有効期限3ヶ月） |
| ホワイトニング1回30%OFF券 | 20個 | 通常\16,500 → \11,550（有効期限3ヶ月） |

**reward_exchangesテーブル（交換履歴）:**

| カラム名 | 型 | 説明 |
|---------|---|------|
| id | UUID | 主キー |
| user_id | TEXT | ユーザーID |
| reward_id | UUID | 特典ID |
| stamp_count_used | INTEGER | 使用したスタンプ数 |
| exchanged_at | TIMESTAMPTZ | 交換日時 |
| status | TEXT | pending / completed / cancelled |
| notes | TEXT | メモ |

### 2.3 API仕様

**GET /api/rewards:** 有効な特典一覧を取得

**POST /api/rewards/exchange:** 特典を交換（積み上げ式）
- リクエスト: `{ userId, rewardId }`
- スタンプ数チェック → 条件を満たしていれば `reward_exchanges` に記録
- スタンプ数は減らさない

### 2.4 ステータス管理

| ステータス | 意味 | 運用 |
|-----------|------|------|
| pending | 交換申請済み | 受付で特典を提供する前 |
| completed | 提供完了 | 受付で実際に特典を渡した後 |
| cancelled | キャンセル | 誤交換などの取り消し |

### 2.5 運用: 特典の追加・変更

```sql
-- 新しい特典を追加
INSERT INTO rewards (name, description, required_stamps, display_order)
VALUES ('歯間ブラシセット', '歯間ブラシ5本セット', 8, 5);

-- 特典を無効化（削除せず非表示）
UPDATE rewards SET is_active = false WHERE id = 'uuid';
```

---

## 3. スタッフ手動スタンプ機能

### 3.1 概要

QRコードが読み取れない場合のリスク対応として、受付スタッフが手動でスタンプ数を変更できる機能。

### 3.2 操作フロー

```
患者からスマホを預かる
  → ページ最下部のバージョン情報を3回連続タップ
  → 暗証番号入力ダイアログ表示
  → 暗証番号「1234」を入力
  → スタンプ数編集画面（+/-ボタン）
  → 「更新」で反映
  → 患者にスマホを返却
```

### 3.3 API仕様

**POST /api/stamps/manual:**

リクエスト:
```json
{
  "userId": "U1234567890abcdef",
  "staffPin": "1234",
  "newStampCount": 6
}
```

動作:
1. 暗証番号チェック
2. `profiles.stamp_count` を直接更新
3. `stamp_history` に監査証跡を記録（`stamp_method: 'manual_admin'`）
4. トリガーで `profiles.stamp_count` が再計算（`MAX(stamp_number)`）

### 3.4 セキュリティ

| 対策 | 内容 |
|-----|------|
| 隠しリンク | 3回連続タップでのみ表示 |
| 暗証番号 | スタッフのみ知っている（環境変数 `NEXT_PUBLIC_STAFF_PIN`） |
| 監査証跡 | stamp_historyに手動付与を記録 |
| スマホ預かり前提 | 患者自身は操作しない |

**監査証跡の識別:**
- `stamp_method`: `'manual_admin'`
- `qr_code_id`: `MANUAL-ADJUST-{YYYYMMDD}-{HHMMSS}` 形式
- `notes`: `スタッフ操作: +1個 (5 → 6)` 等

### 3.5 制限事項

- 操作回数制限なし（柔軟な修正に対応するため）
- スタンプ数の範囲: 0〜999個
- 暗証番号: 月次で変更推奨

---

## 4. LINE友だち登録促進機能

### 4.1 概要

LIFF起動時に `liff.getFriendship()` を使用し、公式LINE（@550mlcao）の友だち登録状態をチェック。未登録の場合に登録を促す。

**目的:**
- 再来院促進（リマインド通知）
- エンゲージメント向上（キャンペーン情報配信）
- 友だち登録状況のSupabase管理

### 4.2 データベース設計

**profiles.is_line_friend カラム:**

| 値 | 意味 |
|---|------|
| NULL | まだ確認していない |
| true | 公式LINEの友だち |
| false | 公式LINEの友だちではない |

### 4.3 表示タイミング

| シーン | 条件 | 頻度 |
|-------|------|------|
| 初回起動時モーダル | `isFriend === false` | 1日1回（LocalStorageで管理） |
| 医院情報ページ | `isFriend === false` | 常に表示 |

### 4.4 実装ファイル

| ファイル | 役割 |
|---------|------|
| hooks/useLiff.ts | `liff.getFriendship()` 呼び出し、Supabaseキャッシュ |
| components/features/FriendshipPromptModal.tsx | 友だち登録促進モーダル |
| components/layout/AppLayout.tsx | 初回起動時モーダル表示制御 |
| components/(adult)/AdultInfoPage.tsx | 友だち登録状態の表示 |

### 4.5 友だち追加フロー

```
モーダルまたは医院情報ページで「友だち追加する」をタップ
  → https://line.me/R/ti/p/@550mlcao を新しいタブで開く
  → ユーザーが公式LINEを友だち追加
  → 次回LIFF起動時に liff.getFriendship() → friendFlag = true
  → Supabase profiles.is_line_friend が自動更新
```

### 4.6 運用: 友だち登録状況の確認

```sql
-- 友だち登録率
SELECT
  ROUND(
    100.0 * COUNT(*) FILTER (WHERE is_line_friend = true) / COUNT(*),
    2
  ) AS friend_rate_percent
FROM profiles;
```

---

## 5. 次回メモ機能

### 5.1 概要

受付スタッフが各患者に対して「次回来院予定日」と「カスタムメッセージ」を設定できる機能。患者のLINEミニアプリのホーム画面に表示される。

**目的:**
- 患者ごとにパーソナライズされたメッセージ提供
- 次回予約日のリマインダー
- 患者エンゲージメントの向上

### 5.2 データベース設計

**profilesテーブルへの追加カラム:**

| カラム名 | 型 | NULL許可 | 説明 |
|---------|---|---------|------|
| next_visit_date | DATE | YES | 次回来院予定日（YYYY-MM-DD形式） |
| next_memo | TEXT | YES | カスタムメッセージ（最大200文字推奨） |
| next_memo_updated_at | TIMESTAMPTZ | YES | メモの最終更新日時（自動更新） |

**インデックス:**
```sql
CREATE INDEX idx_profiles_next_visit_date
  ON profiles(next_visit_date)
  WHERE next_visit_date IS NOT NULL;
```

**自動更新トリガー:**
```sql
CREATE OR REPLACE FUNCTION update_next_memo_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  IF (NEW.next_visit_date IS DISTINCT FROM OLD.next_visit_date)
     OR (NEW.next_memo IS DISTINCT FROM OLD.next_memo) THEN
    NEW.next_memo_updated_at = NOW();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_next_memo_timestamp
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_next_memo_timestamp();
```

### 5.3 API仕様

**GET /api/users/[userId]/memo:**

レスポンス:
```json
{
  "success": true,
  "memo": {
    "next_visit_date": "2026-04-13",
    "next_memo": "お疲れ様です！今日も歯のケア、一緒に頑張りましょう。",
    "next_memo_updated_at": "2026-02-14T19:00:00+09:00"
  }
}
```

**PUT /api/users/[userId]/memo:**

リクエスト:
```json
{
  "next_visit_date": "2026-04-13",
  "next_memo": "お疲れ様です！今日も歯のケア、一緒に頑張りましょう。"
}
```

**バリデーション:**
- `next_visit_date`: YYYY-MM-DD形式の日付（正規表現チェック）
- `next_memo`: 最大200文字（API側で強制）
- どちらも省略可能、`null`または空文字列でクリア可能

### 5.4 患者側表示（AdultHome.tsx）

**表示パターン:**

| パターン | 表示内容 |
|---------|---------|
| 日付あり + メモあり | 「次回の定期検診は2026年4月13日です。<br>お疲れ様です！...」 |
| 日付あり + メモなし | 「次回の定期検診は2026年4月13日です。」 |
| 日付なし + メモあり | 「お疲れ様です！今日も歯のケア、一緒に頑張りましょう。」 |
| どちらもなし | 「次回のご来院をお待ちしております。毎日の歯磨き、頑張りましょう！」（デフォルト） |

**日付フォーマット:**
```typescript
// タイムゾーン問題を回避
const [year, month, day] = dateString.split('-').map(Number);
return `${year}年${month}月${day}日`;
```

### 5.5 管理画面（/admin/memo）

**画面構成:**
- ユーザーID入力（LINE User ID）
- 次回来院予定日（日付ピッカー）
- カスタムメッセージ（テキストエリア、200文字制限）
- プレビュー（リアルタイム表示）
- 保存ボタン / クリアボタン

**ユーザーID取得方法:**
```sql
-- Supabase SQL Editorで患者検索
SELECT id, display_name, ticket_number, stamp_count
FROM profiles
WHERE display_name LIKE '%横山%';
```

### 5.6 運用フロー

```
1. 患者が診察を受ける
   ↓
2. 受付スタッフが次回予約を確認
   ↓
3. 管理画面（/admin/memo）にアクセス
   ↓
4. ユーザーIDを入力（Supabaseで患者名から検索）
   ↓
5. 次回来院予定日を入力（例: 2026-04-13）
   ↓
6. 必要に応じてカスタムメッセージを入力
   ↓
7. プレビューで内容を確認 → 「メモを更新」
   ↓
8. 患者のLINEミニアプリに即座に反映
```

### 5.7 技術的な注意事項

**タイムゾーン問題の回避:**
- `new Date("2026-04-13")` はタイムゾーンによって前日になる可能性がある
- 文字列を直接分解することで問題を回避: `split('-').map(Number)`

**データ整合性:**
- `next_memo_updated_at` はトリガーで自動更新（手動更新不要）
- 文字数制限はAPI側でも強制（フロントエンドだけでは不十分）

**セキュリティ:**
- 現状は認証なしの簡易管理画面
- Phase 7で本格的なスタッフ認証を実装予定
- 本番環境ではIP制限またはBasic認証を推奨

### 5.8 将来の拡張案

- [ ] ユーザー検索機能（名前・診察券番号で検索）
- [ ] メッセージテンプレート機能
- [ ] 変数置換機能（`{name}`, `{stamp_count}` など）
- [ ] 一括設定機能（全患者向けお知らせ）
- [ ] 過去の予定日の自動クリア（バッチ処理）
- [ ] LINE通知連携（予定日の3日前に自動通知）

---

## 6. 予約ボタンクリック数トラッキング機能

### 6.1 概要

LIFF経由での「予約する」ボタンのクリック数を計測し、患者ごとの予約意欲や利用状況を分析できる機能。

**目的:**
- 予約ボタンの利用状況を可視化
- 患者ごとの予約意欲を把握
- スタンプ数とクリック数の相関分析
- 再来院促進施策の効果測定

**設計方針:**
- シンプル設計（カウンターのみ、履歴は記録しない）
- ユーザー体験を妨げない（エラーでも予約ページは開く）
- 非同期処理（カウント失敗でもアプリは動く）

### 6.2 データベース設計

**profilesテーブルへの追加カラム:**

| カラム名 | 型 | NULL許可 | デフォルト | 説明 |
|---------|---|---------|----------|------|
| reservation_button_clicks | INTEGER | NO | 0 | 予約ボタンのクリック回数 |

**マイグレーションSQL:**
```sql
-- profilesテーブルにカラム追加
ALTER TABLE profiles
ADD COLUMN reservation_button_clicks INTEGER DEFAULT 0;

-- コメント追加
COMMENT ON COLUMN profiles.reservation_button_clicks IS '予約ボタンのクリック回数（累積）';

-- インデックス作成（クリック数でのソートや集計を高速化）
CREATE INDEX IF NOT EXISTS idx_profiles_reservation_clicks
  ON profiles(reservation_button_clicks);

-- 安全にカウントアップする関数
CREATE OR REPLACE FUNCTION increment_reservation_clicks(p_user_id TEXT)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
  new_count INTEGER;
BEGIN
  -- 該当ユーザーのクリック数を+1（NULLの場合は0として扱う）
  UPDATE profiles
  SET reservation_button_clicks = COALESCE(reservation_button_clicks, 0) + 1
  WHERE id = p_user_id
  RETURNING reservation_button_clicks INTO new_count;

  -- 更新された値を返す（ユーザーが存在しない場合は0）
  RETURN COALESCE(new_count, 0);
END;
$$;

-- 関数のコメント
COMMENT ON FUNCTION increment_reservation_clicks(TEXT) IS '予約ボタンのクリック数を安全に+1する関数（排他制御付き）';
```

### 6.3 API仕様

**POST /api/users/[userId]/reservation-click**

クリックをカウントするためのシンプルなAPI。データベース関数 `increment_reservation_clicks()` を使用して安全にカウントアップ。

**リクエスト:**
```
POST /api/users/U1234567890abcdef/reservation-click
Content-Type: application/json

{}
```

**レスポンス（成功）:**
```json
{
  "success": true,
  "message": "クリック数を更新しました",
  "clicks": 3
}
```

**レスポンス（エラー）:**
```json
{
  "success": false,
  "message": "ユーザーが見つかりません",
  "error": "User not found"
}
```

**動作:**
1. データベース関数 `increment_reservation_clicks(user_id)` を呼び出し
2. 関数内で `profiles.reservation_button_clicks` を安全に +1
3. 更新後のクリック数を返す

**データベース関数を使う理由:**
- **排他制御**: 複数リクエストが同時に来ても正しくカウント
- **NULL安全**: NULLの場合も0として扱う
- **パフォーマンス**: 1回のクエリで完結

**エラーハンドリング:**
- ユーザーが存在しない → 404エラー（関数は0を返す）
- データベースエラー → 500エラー
- **重要**: フロントエンド側でエラーを握りつぶす（ユーザー体験を妨げない）

### 6.4 フロントエンド実装

**修正対象ファイル:**
- `components/(adult)/AdultHome.tsx`
- `components/(kids)/KidsHome.tsx`（将来実装時）

**修正箇所: handleReservation関数**

```typescript
const handleReservation = async () => {
  if (displayTicketNumber === "未登録") {
    alert("診察券番号が登録されていません。受付にお声がけください。");
    return;
  }

  try {
    // 診察券番号をコピー
    await navigator.clipboard.writeText(displayTicketNumber);
    alert(
      `診察券番号をコピーしました！\n予約画面で貼り付けてください。\n\n診察券番号: ${displayTicketNumber}`
    );

    // 🆕 予約ボタンのクリック数をカウント
    if (profile?.userId) {
      fetch(`/api/users/${profile.userId}/reservation-click`, {
        method: "POST",
      }).catch((error) => {
        // エラーでもユーザー体験は妨げない
        console.error("⚠️ クリックカウントエラー:", error);
      });
    }

    // アポツールを開く
    window.open(
      "https://reservation.stransa.co.jp/5d62710843af2685c64352ed3eb9d043",
      "_blank"
    );
  } catch (error) {
    console.error("❌ 予約ボタンエラー:", error);
    alert("エラーが発生しました。もう一度お試しください。");
  }
};
```

**実装のポイント:**
1. `.catch()` でエラーを握りつぶす → 予約ページは必ず開く
2. `profile?.userId` のnullチェック必須
3. 非同期処理（await なし）→ カウント完了を待たずに予約ページを開く

### 6.5 統計分析SQL

**全体のクリック数:**
```sql
SELECT SUM(reservation_button_clicks) AS total_clicks
FROM profiles;
```

**ユーザーごとのクリック数（トップ10）:**
```sql
SELECT
  display_name AS 患者名,
  ticket_number AS 診察券番号,
  reservation_button_clicks AS クリック数,
  stamp_count AS スタンプ数
FROM profiles
WHERE reservation_button_clicks > 0
ORDER BY reservation_button_clicks DESC
LIMIT 10;
```

**クリック率（スタンプ数との比較）:**
```sql
SELECT
  AVG(reservation_button_clicks::FLOAT / NULLIF(stamp_count, 0)) AS 平均クリック率
FROM profiles
WHERE stamp_count > 0;
```

**クリック数の分布:**
```sql
SELECT
  reservation_button_clicks AS クリック数,
  COUNT(*) AS 患者数
FROM profiles
GROUP BY reservation_button_clicks
ORDER BY reservation_button_clicks DESC;
```

### 6.6 管理ダッシュボードでの表示（Phase 7実装予定）

**表示予定項目:**
1. **総クリック数**: 全患者の合計
2. **平均クリック数**: 1患者あたりの平均
3. **クリック率**: スタンプ数に対するクリック割合
4. **トップ10リスト**: クリック数が多い患者

**活用例:**
- 予約システムの利用状況把握
- 「スタンプは貯まるが予約しない患者」の抽出
- 再来院促進施策の効果測定

### 6.7 将来の拡張案

- [ ] クリック履歴テーブル（いつクリックしたかを記録）
- [ ] ページ別トラッキング（ホームページ vs 医院情報ページ）
- [ ] A/Bテスト用の variant パラメータ
- [ ] Google Analytics連携
- [ ] 実際の予約完了率との比較分析

### 6.8 制限事項

**データの正確性:**
- オフライン時のクリックはカウントされない（仕様）
- API失敗時もカウント漏れが発生（ユーザー体験優先のため許容）
- ブラウザでJavaScriptが無効の場合はカウント不可

**プライバシー:**
- クリック数のみを記録（どのページを見たかは記録しない）
- 個人を特定する情報は含まない

---

## 改訂履歴

| 日付 | 内容 |
|------|------|
| 2026-02-14 | 予約ボタンクリック数トラッキング機能仕様を追加（6章） |
| 2026-02-14 | 次回メモ機能仕様を追加（5章） |
| 2026-02-11 | 4つの仕様書を統合（Feature_Specifications.md 初版） |
| 2026-02-09 | スタンプシステム設計書 初版 |
| 2026-02-09 | 特典交換システム仕様書 v1.0→v1.1（積み上げ式に変更） |
| 2026-02-09 | スタッフ手動スタンプ仕様書 v1.0→v2.0（自由編集機能） |
| 2026-02-09 | LINE友だち登録促進機能仕様書 初版 |

---

**統合元ファイル（Doc/archive/ に保存）:**
- Stamp_System_Design.md
- Rewards_System_Specification.md
- Staff_Manual_Stamp_Specification.md
- LINE_Friendship_Feature_Specification.md
