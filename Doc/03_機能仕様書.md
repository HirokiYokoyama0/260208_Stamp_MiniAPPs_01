# 機能仕様書（統合版）

各機能の詳細仕様を1ファイルに集約。元ファイルは Doc/archive/ に保存。

---

## 1. スタンプシステム

### 1.1 基本仕様

**スタンプ付与ルール:**
- 1回の来院 = 10個のスタンプを付与
- スロットゲーム = 3〜8個のスタンプを追加付与
- **DB表現**: `stamp_count` は整数値で保存（10, 20, 30, 40, 135...）
- **画面表示**: `stamp_count` をそのまま表示（10個、20個、30個、40個、135個...）

**スタッフ編集機能:**
- 目的: 誤登録の修正、テスト用途
- 制限: なし（何度でも編集可能）
- 監査証跡: すべての編集履歴を `stamp_history` に記録
- **注意**: スタッフが「50個に設定」と指定した場合、DB には 50 を登録すること

### 1.2 データベース設計

**stamp_historyテーブル:**

| カラム名 | 型 | 説明 |
|---------|---|------|
| id | UUID | 主キー |
| user_id | TEXT | ユーザーID（profiles.id） |
| visit_date | TIMESTAMPTZ | 来院日時 |
| stamp_number | INTEGER | その時点でのスタンプ数（累積） |
| stamp_method | TEXT | 登録方法（'qr_scan' / 'manual_admin' / 'import' / 'survey_reward'） |
| qr_code_id | TEXT | QRコードID |
| notes | TEXT | メモ |
| created_at | TIMESTAMPTZ | 作成日時 |
| updated_at | TIMESTAMPTZ | 更新日時 |

**stamp_numberの意味（重要）:**

`stamp_number` は「その時点でのスタンプ数（累積）」を表す。

```
| visit_date | stamp_number | stamp_method | 説明 |
|-----------|--------------|--------------|------|
| 2月8日 09:00 | 10 | qr_scan | 1回目の来院 → スタンプ10個 |
| 2月9日 10:00 | 20 | qr_scan | 2回目の来院 → 累積20個 |
| 2月9日 10:30 | 50 | manual_admin | スタッフが「50個に設定」|
| 2月9日 11:00 | 40 | manual_admin | スタッフが「40個に修正」|
```

**訪問回数とスタンプ数の区別:**
- 訪問回数 = `stamp_history` テーブルのレコード数
- スタンプ数 = `MAX(stamp_number)` = `profiles.stamp_count`

### 1.3 トリガー関数: update_profile_stamp_count()

```sql
CREATE OR REPLACE FUNCTION update_profile_stamp_count()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE profiles
  SET
    stamp_count = (
      SELECT COALESCE(MAX(stamp_number), 0)
      FROM stamp_history
      WHERE user_id = NEW.user_id
    ),
    last_visit_date = (
      SELECT MAX(visit_date)
      FROM stamp_history
      WHERE user_id = NEW.user_id
    ),
    updated_at = NOW()
  WHERE id = NEW.user_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

`MAX(stamp_number)` を使用する理由: スタッフ編集でスタンプ数を自由に設定できるようにするため。`COUNT(*)` ではレコード数（訪問回数）しか取得できない。

### 1.4 API仕様

**POST /api/stamps（QRスキャン）:**
1. 現在のスタンプ数を取得（`profiles.stamp_count`）
2. 次のスタンプ数を計算（`currentStampCount + 10`）
3. `stamp_history` に新規レコードを挿入
4. トリガーで `profiles.stamp_count` が自動更新される

**重複チェック:** 同日同QRコードIDの組み合わせで重複防止

### 1.5 画面表示

**スタンプページ（/stamp）:**
- スタンプカウンター: `profiles.stamp_count` を表示
- 訪問回数: `stamp_history` のレコード数を表示
- 来院履歴リスト: 訪問回数、スタンプ数、スタッフ編集フラグ
- QRスキャンボタン

### 1.6 トラブルシューティング

| 症状 | 対処 |
|-----|------|
| スタンプ数が正しくない | トリガー関数が `MAX(stamp_number)` を使っているか確認 |
| 既存データが不正 | `UPDATE profiles SET stamp_count = (SELECT COALESCE(MAX(stamp_number), 0) FROM stamp_history WHERE user_id = profiles.id);` |
| 訪問回数とスタンプ数が混同 | 訪問回数=レコード数、スタンプ数=MAX(stamp_number) |

---

## 2. 特典交換システム

### 2.1 概要

貯まったスタンプで特典と交換できるシステム。患者の再来院モチベーション向上を目的とする。

**積み上げ式（v1.1で変更）:**
- スタンプは交換後も減らない
- 条件を満たせば何度でも交換可能
- 例: 20個貯まれば、5個/10個/15個/20個の特典すべて交換可能

### 2.2 データベース設計

**rewardsテーブル（特典マスター）:**

| カラム名 | 型 | 説明 |
|---------|---|------|
| id | UUID | 主キー |
| name | TEXT | 特典名 |
| description | TEXT | 詳細説明 |
| required_stamps | INTEGER | 必要なスタンプ数 |
| image_url | TEXT | 特典画像URL（オプション） |
| is_active | BOOLEAN | 有効/無効 |
| display_order | INTEGER | 表示順序 |
| created_at | TIMESTAMPTZ | 作成日時 |
| updated_at | TIMESTAMPTZ | 更新日時 |

**初期特典データ:**

| 特典名 | 必要スタンプ | 内容 |
|-------|-----------|------|
| オリジナル歯ブラシセット | 50個 | 歯ブラシ + 歯磨き粉 |
| フッ素塗布1回無料券 | 100個 | 通常\1,100 → 無料（有効期限6ヶ月） |
| 歯のクリーニング50%OFF券 | 150個 | 通常\5,500 → \2,750（有効期限3ヶ月） |
| ホワイトニング1回30%OFF券 | 200個 | 通常\16,500 → \11,550（有効期限3ヶ月） |

**reward_exchangesテーブル（交換履歴）:**

| カラム名 | 型 | 説明 |
|---------|---|------|
| id | UUID | 主キー |
| user_id | TEXT | ユーザーID |
| reward_id | UUID | 特典ID |
| stamp_count_used | INTEGER | 使用したスタンプ数 |
| exchanged_at | TIMESTAMPTZ | 交換日時 |
| status | TEXT | pending / completed / cancelled |
| notes | TEXT | メモ |

### 2.3 API仕様

**GET /api/rewards:** 有効な特典一覧を取得

**POST /api/rewards/exchange:** 特典を交換（積み上げ式）
- リクエスト: `{ userId, rewardId }`
- スタンプ数チェック → 条件を満たしていれば `reward_exchanges` に記録
- スタンプ数は減らさない

### 2.4 ステータス管理

| ステータス | 意味 | 運用 |
|-----------|------|------|
| pending | 交換申請済み | 受付で特典を提供する前 |
| completed | 提供完了 | 受付で実際に特典を渡した後 |
| cancelled | キャンセル | 誤交換などの取り消し |

### 2.5 運用: 特典の追加・変更

```sql
-- 新しい特典を追加
INSERT INTO rewards (name, description, required_stamps, display_order)
VALUES ('歯間ブラシセット', '歯間ブラシ5本セット', 8, 5);

-- 特典を無効化（削除せず非表示）
UPDATE rewards SET is_active = false WHERE id = 'uuid';
```

---

## 3. スタッフ手動スタンプ機能

### 3.1 概要

QRコードが読み取れない場合のリスク対応として、受付スタッフが手動でスタンプ数を変更できる機能。

### 3.2 操作フロー

```
患者からスマホを預かる
  → ページ最下部のバージョン情報を3回連続タップ
  → 暗証番号入力ダイアログ表示
  → 暗証番号「1234」を入力
  → スタンプ数編集画面（+/-ボタン）
  → 「更新」で反映
  → 患者にスマホを返却
```

### 3.3 API仕様

**POST /api/stamps/manual:**

リクエスト:
```json
{
  "userId": "U1234567890abcdef",
  "staffPin": "1234",
  "newStampCount": 60
}
```

動作:
1. 暗証番号チェック
2. `profiles.stamp_count` を直接更新
3. `stamp_history` に監査証跡を記録（`stamp_method: 'manual_admin'`）
4. トリガーで `profiles.stamp_count` が再計算（`MAX(stamp_number)`）

### 3.4 セキュリティ

| 対策 | 内容 |
|-----|------|
| 隠しリンク | 3回連続タップでのみ表示 |
| 暗証番号 | スタッフのみ知っている（環境変数 `NEXT_PUBLIC_STAFF_PIN`） |
| 監査証跡 | stamp_historyに手動付与を記録 |
| スマホ預かり前提 | 患者自身は操作しない |

**監査証跡の識別:**
- `stamp_method`: `'manual_admin'`
- `qr_code_id`: `MANUAL-ADJUST-{YYYYMMDD}-{HHMMSS}` 形式
- `notes`: `スタッフ操作: +10個 (50 → 60)` 等

### 3.5 制限事項

- 操作回数制限なし（柔軟な修正に対応するため）
- スタンプ数の範囲: 0〜999個
- 暗証番号: 月次で変更推奨

---

## 4. LINE友だち登録促進機能

### 4.1 概要

LIFF起動時に `liff.getFriendship()` を使用し、公式LINE（@550mlcao）の友だち登録状態をチェック。未登録の場合に登録を促す。

**目的:**
- 再来院促進（リマインド通知）
- エンゲージメント向上（キャンペーン情報配信）
- 友だち登録状況のSupabase管理

### 4.2 データベース設計

**profiles.is_line_friend カラム:**

| 値 | 意味 |
|---|------|
| NULL | まだ確認していない |
| true | 公式LINEの友だち |
| false | 公式LINEの友だちではない |

### 4.3 表示タイミング

| シーン | 条件 | 頻度 |
|-------|------|------|
| 初回起動時モーダル | `isFriend === false` | 1日1回（LocalStorageで管理） |
| 医院情報ページ | `isFriend === false` | 常に表示 |

### 4.4 実装ファイル

| ファイル | 役割 |
|---------|------|
| hooks/useLiff.ts | `liff.getFriendship()` 呼び出し、Supabaseキャッシュ |
| components/features/FriendshipPromptModal.tsx | 友だち登録促進モーダル |
| components/layout/AppLayout.tsx | 初回起動時モーダル表示制御 |
| components/(adult)/AdultInfoPage.tsx | 友だち登録状態の表示 |

### 4.5 友だち追加フロー

```
モーダルまたは医院情報ページで「友だち追加する」をタップ
  → https://line.me/R/ti/p/@550mlcao を新しいタブで開く
  → ユーザーが公式LINEを友だち追加
  → 次回LIFF起動時に liff.getFriendship() → friendFlag = true
  → Supabase profiles.is_line_friend が自動更新
```

### 4.6 運用: 友だち登録状況の確認

```sql
-- 友だち登録率
SELECT
  ROUND(
    100.0 * COUNT(*) FILTER (WHERE is_line_friend = true) / COUNT(*),
    2
  ) AS friend_rate_percent
FROM profiles;
```

---

## 5. 次回メモ機能

### 5.1 概要

受付スタッフが各患者に対して「次回来院予定日」と「カスタムメッセージ」を設定できる機能。患者のLINEミニアプリのホーム画面に表示される。

**目的:**
- 患者ごとにパーソナライズされたメッセージ提供
- 次回予約日のリマインダー
- 患者エンゲージメントの向上

### 5.2 データベース設計

**profilesテーブルへの追加カラム:**

| カラム名 | 型 | NULL許可 | 説明 |
|---------|---|---------|------|
| next_visit_date | DATE | YES | 次回来院予定日（YYYY-MM-DD形式） |
| next_memo | TEXT | YES | カスタムメッセージ（最大200文字推奨） |
| next_memo_updated_at | TIMESTAMPTZ | YES | メモの最終更新日時（自動更新） |

**インデックス:**
```sql
CREATE INDEX idx_profiles_next_visit_date
  ON profiles(next_visit_date)
  WHERE next_visit_date IS NOT NULL;
```

**自動更新トリガー:**
```sql
CREATE OR REPLACE FUNCTION update_next_memo_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  IF (NEW.next_visit_date IS DISTINCT FROM OLD.next_visit_date)
     OR (NEW.next_memo IS DISTINCT FROM OLD.next_memo) THEN
    NEW.next_memo_updated_at = NOW();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_next_memo_timestamp
BEFORE UPDATE ON profiles
FOR EACH ROW
EXECUTE FUNCTION update_next_memo_timestamp();
```

### 5.3 API仕様

**GET /api/users/[userId]/memo:**

レスポンス:
```json
{
  "success": true,
  "memo": {
    "next_visit_date": "2026-04-13",
    "next_memo": "お疲れ様です！今日も歯のケア、一緒に頑張りましょう。",
    "next_memo_updated_at": "2026-02-14T19:00:00+09:00"
  }
}
```

**PUT /api/users/[userId]/memo:**

リクエスト:
```json
{
  "next_visit_date": "2026-04-13",
  "next_memo": "お疲れ様です！今日も歯のケア、一緒に頑張りましょう。"
}
```

**バリデーション:**
- `next_visit_date`: YYYY-MM-DD形式の日付（正規表現チェック）
- `next_memo`: 最大200文字（API側で強制）
- どちらも省略可能、`null`または空文字列でクリア可能

### 5.4 患者側表示（AdultHome.tsx）

**表示パターン:**

| パターン | 表示内容 |
|---------|---------|
| 日付あり + メモあり | 「次回の定期検診は2026年4月13日です。<br>お疲れ様です！...」 |
| 日付あり + メモなし | 「次回の定期検診は2026年4月13日です。」 |
| 日付なし + メモあり | 「お疲れ様です！今日も歯のケア、一緒に頑張りましょう。」 |
| どちらもなし | 「次回のご来院をお待ちしております。毎日の歯磨き、頑張りましょう！」（デフォルト） |

**日付フォーマット:**
```typescript
// タイムゾーン問題を回避
const [year, month, day] = dateString.split('-').map(Number);
return `${year}年${month}月${day}日`;
```

### 5.5 管理画面（/admin/memo）

**画面構成:**
- ユーザーID入力（LINE User ID）
- 次回来院予定日（日付ピッカー）
- カスタムメッセージ（テキストエリア、200文字制限）
- プレビュー（リアルタイム表示）
- 保存ボタン / クリアボタン

**ユーザーID取得方法:**
```sql
-- Supabase SQL Editorで患者検索
SELECT id, display_name, ticket_number, stamp_count
FROM profiles
WHERE display_name LIKE '%横山%';
```

### 5.6 運用フロー

```
1. 患者が診察を受ける
   ↓
2. 受付スタッフが次回予約を確認
   ↓
3. 管理画面（/admin/memo）にアクセス
   ↓
4. ユーザーIDを入力（Supabaseで患者名から検索）
   ↓
5. 次回来院予定日を入力（例: 2026-04-13）
   ↓
6. 必要に応じてカスタムメッセージを入力
   ↓
7. プレビューで内容を確認 → 「メモを更新」
   ↓
8. 患者のLINEミニアプリに即座に反映
```

### 5.7 技術的な注意事項

**タイムゾーン問題の回避:**
- `new Date("2026-04-13")` はタイムゾーンによって前日になる可能性がある
- 文字列を直接分解することで問題を回避: `split('-').map(Number)`

**データ整合性:**
- `next_memo_updated_at` はトリガーで自動更新（手動更新不要）
- 文字数制限はAPI側でも強制（フロントエンドだけでは不十分）

**セキュリティ:**
- 現状は認証なしの簡易管理画面
- Phase 7で本格的なスタッフ認証を実装予定
- 本番環境ではIP制限またはBasic認証を推奨

### 5.8 将来の拡張案

- [ ] ユーザー検索機能（名前・診察券番号で検索）
- [ ] メッセージテンプレート機能
- [ ] 変数置換機能（`{name}`, `{stamp_count}` など）
- [ ] 一括設定機能（全患者向けお知らせ）
- [ ] 過去の予定日の自動クリア（バッチ処理）
- [ ] LINE通知連携（予定日の3日前に自動通知）

---

## 6. 予約ボタンクリック数トラッキング機能

### 6.1 概要

LIFF経由での「予約する」ボタンのクリック数を計測し、患者ごとの予約意欲や利用状況を分析できる機能。

**目的:**
- 予約ボタンの利用状況を可視化
- 患者ごとの予約意欲を把握
- スタンプ数とクリック数の相関分析
- 再来院促進施策の効果測定

**設計方針:**
- シンプル設計（カウンターのみ、履歴は記録しない）
- ユーザー体験を妨げない（エラーでも予約ページは開く）
- 非同期処理（カウント失敗でもアプリは動く）

### 6.2 データベース設計

**profilesテーブルへの追加カラム:**

| カラム名 | 型 | NULL許可 | デフォルト | 説明 |
|---------|---|---------|----------|------|
| reservation_button_clicks | INTEGER | NO | 0 | 予約ボタンのクリック回数 |

**マイグレーションSQL:**
```sql
-- profilesテーブルにカラム追加
ALTER TABLE profiles
ADD COLUMN reservation_button_clicks INTEGER DEFAULT 0;

-- コメント追加
COMMENT ON COLUMN profiles.reservation_button_clicks IS '予約ボタンのクリック回数（累積）';

-- インデックス作成（クリック数でのソートや集計を高速化）
CREATE INDEX IF NOT EXISTS idx_profiles_reservation_clicks
  ON profiles(reservation_button_clicks);

-- 安全にカウントアップする関数
CREATE OR REPLACE FUNCTION increment_reservation_clicks(p_user_id TEXT)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
  new_count INTEGER;
BEGIN
  -- 該当ユーザーのクリック数を+1（NULLの場合は0として扱う）
  UPDATE profiles
  SET reservation_button_clicks = COALESCE(reservation_button_clicks, 0) + 1
  WHERE id = p_user_id
  RETURNING reservation_button_clicks INTO new_count;

  -- 更新された値を返す（ユーザーが存在しない場合は0）
  RETURN COALESCE(new_count, 0);
END;
$$;

-- 関数のコメント
COMMENT ON FUNCTION increment_reservation_clicks(TEXT) IS '予約ボタンのクリック数を安全に+1する関数（排他制御付き）';
```

### 6.3 API仕様

**POST /api/users/[userId]/reservation-click**

クリックをカウントするためのシンプルなAPI。データベース関数 `increment_reservation_clicks()` を使用して安全にカウントアップ。

**リクエスト:**
```
POST /api/users/U1234567890abcdef/reservation-click
Content-Type: application/json

{}
```

**レスポンス（成功）:**
```json
{
  "success": true,
  "message": "クリック数を更新しました",
  "clicks": 3
}
```

**レスポンス（エラー）:**
```json
{
  "success": false,
  "message": "ユーザーが見つかりません",
  "error": "User not found"
}
```

**動作:**
1. データベース関数 `increment_reservation_clicks(user_id)` を呼び出し
2. 関数内で `profiles.reservation_button_clicks` を安全に +1
3. 更新後のクリック数を返す

**データベース関数を使う理由:**
- **排他制御**: 複数リクエストが同時に来ても正しくカウント
- **NULL安全**: NULLの場合も0として扱う
- **パフォーマンス**: 1回のクエリで完結

**エラーハンドリング:**
- ユーザーが存在しない → 404エラー（関数は0を返す）
- データベースエラー → 500エラー
- **重要**: フロントエンド側でエラーを握りつぶす（ユーザー体験を妨げない）

### 6.4 フロントエンド実装

**修正対象ファイル:**
- `components/(adult)/AdultHome.tsx`
- `components/(kids)/KidsHome.tsx`（将来実装時）

**修正箇所: handleReservation関数**

```typescript
const handleReservation = async () => {
  if (displayTicketNumber === "未登録") {
    alert("診察券番号が登録されていません。受付にお声がけください。");
    return;
  }

  try {
    // 診察券番号をコピー
    await navigator.clipboard.writeText(displayTicketNumber);
    alert(
      `診察券番号をコピーしました！\n予約画面で貼り付けてください。\n\n診察券番号: ${displayTicketNumber}`
    );

    // 🆕 予約ボタンのクリック数をカウント
    if (profile?.userId) {
      fetch(`/api/users/${profile.userId}/reservation-click`, {
        method: "POST",
      }).catch((error) => {
        // エラーでもユーザー体験は妨げない
        console.error("⚠️ クリックカウントエラー:", error);
      });
    }

    // アポツールを開く
    window.open(
      "https://reservation.stransa.co.jp/5d62710843af2685c64352ed3eb9d043",
      "_blank"
    );
  } catch (error) {
    console.error("❌ 予約ボタンエラー:", error);
    alert("エラーが発生しました。もう一度お試しください。");
  }
};
```

**実装のポイント:**
1. `.catch()` でエラーを握りつぶす → 予約ページは必ず開く
2. `profile?.userId` のnullチェック必須
3. 非同期処理（await なし）→ カウント完了を待たずに予約ページを開く

### 6.5 統計分析SQL

**全体のクリック数:**
```sql
SELECT SUM(reservation_button_clicks) AS total_clicks
FROM profiles;
```

**ユーザーごとのクリック数（トップ10）:**
```sql
SELECT
  display_name AS 患者名,
  ticket_number AS 診察券番号,
  reservation_button_clicks AS クリック数,
  stamp_count AS スタンプ数
FROM profiles
WHERE reservation_button_clicks > 0
ORDER BY reservation_button_clicks DESC
LIMIT 10;
```

**クリック率（スタンプ数との比較）:**
```sql
SELECT
  AVG(reservation_button_clicks::FLOAT / NULLIF(stamp_count, 0)) AS 平均クリック率
FROM profiles
WHERE stamp_count > 0;
```

**クリック数の分布:**
```sql
SELECT
  reservation_button_clicks AS クリック数,
  COUNT(*) AS 患者数
FROM profiles
GROUP BY reservation_button_clicks
ORDER BY reservation_button_clicks DESC;
```

### 6.6 管理ダッシュボードでの表示（Phase 7実装予定）

**表示予定項目:**
1. **総クリック数**: 全患者の合計
2. **平均クリック数**: 1患者あたりの平均
3. **クリック率**: スタンプ数に対するクリック割合
4. **トップ10リスト**: クリック数が多い患者

**活用例:**
- 予約システムの利用状況把握
- 「スタンプは貯まるが予約しない患者」の抽出
- 再来院促進施策の効果測定

### 6.7 将来の拡張案

- [ ] クリック履歴テーブル（いつクリックしたかを記録）
- [ ] ページ別トラッキング（ホームページ vs 医院情報ページ）
- [ ] A/Bテスト用の variant パラメータ
- [ ] Google Analytics連携
- [ ] 実際の予約完了率との比較分析

### 6.8 制限事項

**データの正確性:**
- オフライン時のクリックはカウントされない（仕様）
- API失敗時もカウント漏れが発生（ユーザー体験優先のため許容）
- ブラウザでJavaScriptが無効の場合はカウント不可

**プライバシー:**
- クリック数のみを記録（どのページを見たかは記録しない）
- 個人を特定する情報は含まない

---

## 7. 家族紐付け機能（Phase 2）

### 7.1 概要

親子で協力してスタンプを貯める「家族連携機能」。初回登録時に親（保護者）または子（メンバー）を選択し、招待コードで家族に参加できる。

**目的:**
- 親子で協力してスタンプを貯めるモチベーション向上
- 家族全体のスタンプ数を可視化
- 家族単位での特典交換促進

**主な機能:**
1. 初回登録時のロール選択（親 or 子）
2. 家族の作成（親が新規家族を自動作成）
3. 家族への参加（子が招待コードで参加）
4. 家族スタンプ合算表示（family_stamp_totals ビュー）
5. 家族管理（親専用: メンバー一覧、家族名変更、メンバー削除）
6. 子供の画面切替（親専用: 代理管理メンバーごとにキッズモード画面表示）

### 7.2 データベース設計

**familiesテーブル:**

| カラム名 | 型 | NULL許可 | 説明 |
|---------|---|---------|------|
| id | TEXT | NO | 家族ID（PRIMARY KEY）招待コードとして使用 |
| family_name | TEXT | NO | 家族名（例: "横山家"） |
| representative_user_id | TEXT | YES | 代表者（親）のユーザーID |
| created_at | TIMESTAMPTZ | NO | 作成日時 |
| updated_at | TIMESTAMPTZ | NO | 更新日時 |

**profilesテーブルへの追加カラム:**

| カラム名 | 型 | NULL許可 | 説明 |
|---------|---|---------|------|
| family_id | TEXT | YES | 所属家族ID（FOREIGN KEY → families.id） |
| family_role | TEXT | YES | ロール: 'parent'（親）または 'child'（子） |

**CHECK制約:**
```sql
ALTER TABLE profiles
ADD CONSTRAINT check_family_role
CHECK (family_role IN ('parent', 'child'));
```

**外部キー制約:**
```sql
ALTER TABLE profiles
ADD CONSTRAINT fk_profiles_family_id
FOREIGN KEY (family_id) REFERENCES families(id)
ON DELETE SET NULL;
```

**family_stamp_totalsビュー:**
```sql
CREATE VIEW family_stamp_totals AS
SELECT
  f.id AS family_id,
  f.family_name,
  COUNT(p.id) AS member_count,
  COALESCE(SUM(p.stamp_count), 0) AS total_stamp_count,
  COALESCE(SUM(p.visit_count), 0) AS total_visit_count
FROM families f
LEFT JOIN profiles p ON p.family_id = f.id
GROUP BY f.id, f.family_name;
```

**インデックス:**
```sql
CREATE INDEX idx_profiles_family_id ON profiles(family_id);
CREATE INDEX idx_families_representative ON families(representative_user_id);
```

### 7.3 API仕様

**GET /api/users/me:**

ユーザー情報 + 家族情報を取得。

レスポンス:
```json
{
  "success": true,
  "profile": {
    "id": "U3c2f1a651af...",
    "display_name": "横山浩紀",
    "family_id": "abc123-def456-...",
    "family_role": "parent",
    "families": {
      "id": "abc123-def456-...",
      "family_name": "横山家",
      "representative_user_id": "U3c2f1a651af..."
    }
  }
}
```

**POST /api/users/setup-role:**

初回登録時のロール設定。

リクエスト:
```json
{
  "userId": "U3c2f1a651af...",
  "role": "parent"
}
```

動作:
- `role === 'parent'`: 新規家族を自動作成 → profiles.family_id/family_role を更新
- `role === 'child'`: profiles.family_role のみ更新（family_id は NULL のまま）

レスポンス（親の場合）:
```json
{
  "success": true,
  "family": {
    "id": "abc123-def456-...",
    "family_name": "横山浩紀の家族",
    "representative_user_id": "U3c2f1a651af..."
  }
}
```

**POST /api/families/join:**

子どもが招待コードで家族に参加。

リクエスト:
```json
{
  "userId": "U1234567890...",
  "inviteCode": "abc123-def456-..."
}
```

動作:
1. inviteCode（families.id）で家族を検索
2. 見つかった場合、profiles.family_id を更新
3. 見つからない場合、400エラー

レスポンス（成功）:
```json
{
  "success": true,
  "family": {
    "id": "abc123-def456-...",
    "family_name": "横山家"
  }
}
```

**GET /api/families/me:**

家族詳細 + メンバー一覧を取得（親・子ともに利用可能）。

リクエスト:
```
GET /api/families/me?userId=U3c2f1a651af...
```

レスポンス:
```json
{
  "success": true,
  "family": {
    "id": "abc123-def456-...",
    "family_name": "横山家",
    "representative_user_id": "U3c2f1a651af...",
    "created_at": "2026-02-17T10:00:00+09:00",
    "updated_at": "2026-02-17T10:00:00+09:00"
  },
  "members": [
    {
      "id": "U3c2f1a651af...",
      "display_name": "横山浩紀",
      "family_role": "parent",
      "stamp_count": 120,
      "visit_count": 12
    },
    {
      "id": "U1234567890...",
      "display_name": "横山太郎",
      "family_role": "child",
      "stamp_count": 80,
      "visit_count": 8
    }
  ],
  "familyTotal": {
    "family_id": "abc123-def456-...",
    "family_name": "横山家",
    "member_count": 2,
    "total_stamp_count": 200,
    "total_visit_count": 20
  }
}
```

**PATCH /api/families/update:**

家族名の変更（親専用）。

リクエスト:
```json
{
  "userId": "U3c2f1a651af...",
  "familyName": "新しい家族名"
}
```

バリデーション:
- family_role === 'parent' のチェック
- family_name の文字数制限（1〜50文字）

レスポンス:
```json
{
  "success": true,
  "family": {
    "id": "abc123-def456-...",
    "family_name": "新しい家族名"
  }
}
```

**DELETE /api/families/members:**

メンバーの削除（親専用、子のみ削除可能）。

リクエスト:
```json
{
  "userId": "U3c2f1a651af...",
  "memberId": "U1234567890..."
}
```

バリデーション:
- family_role === 'parent' のチェック
- 削除対象が 'parent' でないことをチェック
- 削除対象が同じ家族のメンバーであることをチェック

動作:
- 対象メンバーの profiles.family_id を NULL に設定

レスポンス:
```json
{
  "success": true
}
```

### 7.4 UI実装

**1. 初回ロール選択画面（/onboarding）:**

- 親（User アイコン）/ 子（Baby アイコン）の2択ボタン
- useLiff() でLINEユーザー情報取得
- 選択後、POST /api/users/setup-role でロール設定
- 親 → / へ、子 → /family/join へリダイレクト

**2. 家族参加画面（/family/join）:**

- 招待コード入力フィールド（36文字のUUID形式）
- クリップボードから貼り付けボタン
- POST /api/families/join で家族参加
- 成功時 → / へリダイレクト
- ヘルプセクション: 招待コードの取得方法を説明
- QRコード読み取りボタン（将来実装用、現在は disabled）

**3. 家族管理画面（/family/manage）:**

親専用画面。

機能:
- 家族名のインライン編集
- 招待コードの表示 + コピーボタン
- メンバー一覧カード表示:
  - 表示名
  - スタンプ数
  - ロールバッジ（親/子）
- 子の削除ボタン（確認ダイアログ付き）

**4. 設定画面（/settings）:**

3つのセクションで構成:

**① 公式LINE:**
- 友だち登録状態の表示
- 未登録の場合は友だち追加ボタン

**② 家族管理:**
- Users アイコン付きボタン
- ロールに応じた説明文:
  - parent: 「家族メンバーの管理や招待コードの確認」
  - child: 「家族への参加」
  - 未設定: 「家族機能を設定」
- クリック時の遷移先:
  - parent → /family/manage
  - child → /family/join
  - 未設定 → /onboarding

**③ 子供の画面:**
- 表示条件: 親（parent）が代理管理メンバー（line_user_id = NULL）を作成している場合のみ
- 各代理管理メンバーごとにボタンを表示
- ボタン名: 「子供の画面：{子供の名前}」
- タップ時: ViewModeを kids に切り替え → localStorage に selectedChildId を保存 → / へリダイレクト
- **実装上の注意**: `GET /api/families/me` のレスポンス構造は `{ success, family: { members: [...] } }` なので、`familyData.family.members` でアクセスすること
- 詳細は [Doc/70_子供画面切替機能仕様.md](70_子供画面切替機能仕様.md) を参照

### 7.5 フロー図

**親（保護者）の登録フロー:**
```
初回ログイン
  → /onboarding で「保護者」を選択
  → API: POST /api/users/setup-role (role: 'parent')
  → 新規家族を自動作成
  → profiles.family_id, family_role を更新
  → / へリダイレクト
  → ホーム画面に家族スタンプ合計が表示される
```

**子（メンバー）の登録フロー:**
```
初回ログイン
  → /onboarding で「お子様」を選択
  → API: POST /api/users/setup-role (role: 'child')
  → profiles.family_role のみ更新
  → /family/join へリダイレクト
  → 招待コードを入力
  → API: POST /api/families/join
  → profiles.family_id を更新
  → / へリダイレクト
  → ホーム画面に家族スタンプ合計が表示される
```

### 7.6 技術的な設計判断

**1. TEXT型の採用:**
- LINE User IDがUUID形式ではない（"U" + 32文字の英数字）
- 一貫性のため families.id も TEXT 型に統一
- 招待コードとしても利用（そのまま表示可能）

**2. RLS ポリシーの簡略化:**
- すべて `USING (true)` に設定
- 理由:
  - LINE認証を使用（Supabase Authは未使用）
  - 管理ダッシュボードでのアクセスも必要
  - アクセス制御はAPIレイヤーで実装

**3. 招待コードの設計:**
- families.id をそのまま招待コードとして使用
- UUIDをTEXT化した文字列（36文字）
- 推測困難（ランダム性が高い）
- 将来的にQRコード化も容易

**4. 家族スタンプ合計の自動集計:**
- family_stamp_totals ビューで自動計算
- メンバーの profiles.stamp_count を SUM() するだけ
- リアルタイムで家族合計が更新される

### 7.7 セキュリティ考慮事項

**アクセス制御:**
- 家族名変更: family_role === 'parent' のチェック必須
- メンバー削除: family_role === 'parent' のチェック必須
- 親自身の削除は不可（family_role === 'parent' を削除対象から除外）

**招待コード:**
- 36文字のランダム文字列（UUIDベース）
- 推測困難（総当たり攻撃は事実上不可能）
- コードが漏洩した場合: 家族を削除して新規作成で対応

**データ整合性:**
- 外部キー制約: profiles.family_id → families.id
- ON DELETE SET NULL: 家族削除時、メンバーは家族なし状態に戻る
- CHECK制約: family_role は 'parent' または 'child' のみ

### 7.8 運用フロー

**家族の作成（親）:**
```
1. 初回ログイン → /onboarding で「保護者」選択
2. 自動的に新規家族が作成される
3. /settings → 「家族の管理」をタップ
4. 招待コードをコピー
5. 子どもに招待コードを共有（LINEメッセージ等）
```

**家族への参加（子）:**
```
1. 初回ログイン → /onboarding で「お子様」選択
2. 招待コード入力画面が表示される
3. 親から受け取った招待コードを貼り付け
4. 「家族に参加する」ボタンをタップ
5. ホーム画面で家族スタンプ合計が表示される
```

**家族管理（親）:**
```
1. /settings → 「家族の管理」をタップ
2. 家族名の編集: 編集ボタン → 新しい名前を入力 → 保存
3. 招待コード確認: コピーボタンでクリップボードにコピー
4. メンバー削除: 削除ボタン → 確認ダイアログ → 削除
```

### 7.9 将来の拡張案

1. **QRコードでの家族参加**
   - 招待コードをQRコード化
   - カメラで読み取って自動参加

2. **家族招待メッセージ**
   - LINEメッセージで招待リンクを送信
   - 「○○さんから家族に招待されました」

3. **家族ランキング**
   - 家族単位でのスタンプランキング
   - 月間TOP10表示

4. **複数の親（共同管理）**
   - representative_user_id を配列化
   - 夫婦で共同管理

5. **家族イベント**
   - 家族全員が来院したらボーナススタンプ
   - 家族限定の特典

### 7.10 トラブルシューティング

| 症状 | 対処 |
|-----|------|
| 招待コードが無効 | families テーブルで該当IDが存在するか確認 |
| 家族に参加できない | profiles.family_role が 'child' に設定されているか確認 |
| 親が削除できない | family_role === 'parent' のチェックロジックを確認 |
| 家族合計が更新されない | family_stamp_totals ビューを再作成 |
| 設定画面に「子供の画面」が表示されない | APIレスポンスアクセスパスを確認: `familyData.family.members`（`familyData.members` ではない） |

---

## 8. イベントログ機能（Phase 2.7）

### 8.1 概要

ユーザー行動ログを記録し、マーケティング分析・効果測定に活用する機能。

**目的:**
- LINE配信の効果測定（メッセージ送信後のアプリ起動率）
- ユーザー行動分析（どの機能がよく使われているか）
- 未読率の把握・離脱ポイントの特定
- マーケティング施策の効果測定

### 8.2 データベース設計

**event_logsテーブル:**

| カラム名 | 型 | 説明 |
|---------|---|------|
| id | UUID | 主キー |
| user_id | TEXT | ユーザーID（profiles.id） |
| event_name | TEXT | イベント種別 |
| source | TEXT | 流入元 |
| metadata | JSONB | 追加データ（JSON形式） |
| created_at | TIMESTAMPTZ | イベント発生日時 |

**データ保持期間:** 400日（約13ヶ月）- 前年同期比較が可能

**集計用ビュー:**
- `daily_active_users`: 日別アクティブユーザー数（DAU）
- `event_summary`: イベント別集計（直近30日）

### 8.3 記録されるイベント

| カテゴリ | イベント名 | 説明 |
|---------|-----------|------|
| **基本** | `app_open` | アプリ起動 |
| **スタンプ** | `stamp_page_view` | スタンプページ閲覧 |
| | `stamp_scan_success` | QRスキャン成功 |
| | `stamp_scan_fail` | QRスキャン失敗 |
| **予約** | `reservation_button_click` | 予約ボタンクリック |
| **ゲーム** | `slot_game_open` | スロットゲーム画面を開く |
| | `slot_game_play` | スロットゲームプレイ |
| **家族** | `family_manage_open` | 家族管理画面を開く |
| | `family_member_add` | 家族メンバー追加 |
| | `family_member_edit` | 家族メンバー編集 |
| | `family_member_delete` | 家族メンバー削除 |
| | `child_mode_enter` | 子供モード開始 |
| | `child_mode_exit` | 子供モード終了 |

### 8.4 実装ファイル

| ファイル | 役割 |
|---------|------|
| lib/analytics.ts | イベントログ送信ユーティリティ |
| supabase/015_create_event_logs_table_ForUser.sql | テーブル作成SQL |
| components/layout/AppLayout.tsx | app_open イベント記録 |
| 各種コンポーネント | 機能ごとのイベント記録 |

### 8.5 分析用SQL例

**日別アクティブユーザー数（DAU）:**
```sql
SELECT date, active_users
FROM daily_active_users
ORDER BY date DESC
LIMIT 30;
```

**スタンプスキャンの成功率:**
```sql
WITH scans AS (
  SELECT
    SUM(CASE WHEN event_name = 'stamp_scan_success' THEN 1 ELSE 0 END) AS successes,
    SUM(CASE WHEN event_name = 'stamp_scan_fail' THEN 1 ELSE 0 END) AS failures
  FROM event_logs
  WHERE created_at >= current_date - interval '30 days'
)
SELECT
  successes,
  failures,
  ROUND(100.0 * successes / (successes + failures), 2) AS success_rate_percent
FROM scans;
```

**詳細仕様:**
- [Doc/83_イベントログ設計（ユーザの操作ログ）.md](83_イベントログ設計（ユーザの操作ログ）.md) - 設計詳細
- [Doc/84_イベントログ仕様_管理ダッシュボード開発者向け.md](84_イベントログ仕様_管理ダッシュボード開発者向け.md) - 管理画面実装ガイド

---

## 改訂履歴

| 日付 | 内容 |
|------|------|
| 2026-02-24 | イベントログ機能仕様を追加（8章） |
| 2026-02-19 | 設定画面の子供画面切替セクション表示バグを修正（7.4、7.10） |
| 2026-02-17 | 家族紐付け機能仕様を追加（7章、Phase 2実装完了） |
| 2026-02-17 | スタンプシステム仕様を整理（1回の来院 = 10個、スロットゲーム = 3〜8個） |
| 2026-02-14 | 予約ボタンクリック数トラッキング機能仕様を追加（6章） |
| 2026-02-14 | 次回メモ機能仕様を追加（5章） |
| 2026-02-11 | 4つの仕様書を統合（Feature_Specifications.md 初版） |
| 2026-02-09 | スタンプシステム設計書 初版 |
| 2026-02-09 | 特典交換システム仕様書 v1.0→v1.1（積み上げ式に変更） |
| 2026-02-09 | スタッフ手動スタンプ仕様書 v1.0→v2.0（自由編集機能） |
| 2026-02-09 | LINE友だち登録促進機能仕様書 初版 |

---

**統合元ファイル（Doc/archive/ に保存）:**
- Stamp_System_Design.md
- Rewards_System_Specification.md
- Staff_Manual_Stamp_Specification.md
- LINE_Friendship_Feature_Specification.md
