# 85_アンケート機能仕様検討

**作成日:** 2026-02-25
**対象:** LIFFスタンプアプリ Phase 2.8
**目的:** 患者満足度調査とエンゲージメント向上のためのアンケート機能実装

---

## 📋 目次

1. [実装方式の比較検討](#1-実装方式の比較検討)
2. [採用方式：画面自作の理由](#2-採用方式画面自作の理由)
3. [**動的アンケート設計（JSONB方式）**](#3-動的アンケート設計jsonb方式)
4. [機能要件](#4-機能要件)
5. [データベース設計](#5-データベース設計)
6. [画面設計](#6-画面設計)
7. [実装フロー](#7-実装フロー)
8. [スタンプ付与ロジック](#8-スタンプ付与ロジック)
9. [管理画面での集計](#9-管理画面での集計)
10. [今後の拡張性](#10-今後の拡張性)

---

## 1. 実装方式の比較検討

### 1.1 比較表

| 手法 | コスト | UX（スムーズさ） | 実装難易度 | 特徴 |
|------|--------|------------------|------------|------|
| **画面自作** | ¥0 | ⭐️⭐️⭐️⭐️⭐️<br>アプリ内完結 | 中<br>（一度作れば使い回せる） | デザイン統一、即時スタンプ付与、シームレスな体験 |
| **Google Forms** | ¥0 | ⭐️⭐️<br>別タブで開く | 低<br>（URLを作るだけ） | 無料で最強だが、「ブラウザで開く」が離脱を生む |
| **formrun** | 条件付無料 | ⭐️⭐️⭐️<br>デザインは綺麗 | 中<br>（埋め込みが必要） | 無料枠はフォーム数1つ制限、API連携は有料プラン |

### 1.2 各方式の詳細

#### ① 画面自作（Next.js + Supabase）
**メリット:**
- ✅ アプリ内で完結（ページ遷移なし）
- ✅ LIFFログイン済み → 本人確認不要
- ✅ 回答送信と同時にスタンプ付与可能
- ✅ デザインが既存画面と統一
- ✅ 「ありがとうございます！スタンプ3pt付与しました」の即時フィードバック
- ✅ イベントログとの連携が容易

**デメリット:**
- ⚠️ 開発工数が必要（初回のみ、2回目以降は使い回せる）
- ⚠️ ~~質問内容変更時にコード修正が必要~~ → **JSONB動的設計なら不要！（詳細は[第3章](#3-動的アンケート設計jsonb方式)）**

#### ② Google Forms
**メリット:**
- ✅ 開発不要（URLを作るだけ）
- ✅ 完全無料
- ✅ 回答の自動集計・グラフ化

**デメリット:**
- ❌ 別タブでブラウザが開く（LIFFアプリから離脱）
- ❌ 回答完了時のスタンプ付与が自動化できない
- ❌ 「誰が回答したか」の連携が面倒（メールアドレス入力など必要）
- ❌ デザインがアプリと異なる

#### ③ formrun
**メリット:**
- ✅ デザインがモダン
- ✅ 埋め込み可能

**デメリット:**
- ❌ 無料枠はフォーム数1つ制限
- ❌ API連携は有料プラン（月額数千円〜）
- ❌ 別サービス依存のリスク

---

## 2. 採用方式：画面自作の理由

### 2.1 結論

**「画面自作（Next.js + Supabase）」を採用する**

### 2.2 理由

#### ① 最高のUX（ユーザー体験）
歯科医院の患者さんは**「面倒な入力を嫌う」**ため、以下が重要:
- LIFFアプリ内で完結（別タブに飛ばない）
- ログイン不要（既にLIFFで本人確認済み）
- 回答後、即座にスタンプ付与の通知
- そのままホーム画面に戻れる

#### ② 既存システムとの親和性
- 既に **Next.js + Supabase** という最強の土台がある
- スタンプ付与ロジック（`increment_stamp` RPC）が既に実装済み
- イベントログシステムとの連携が容易

#### ③ 回答率の最大化
- Google Formsだと「別タブで開く」→ 離脱率UP
- 画面自作なら「1タップで完結」→ 回答率UP

#### ④ 将来の拡張性
- アンケートA、B、C...と複数作成可能
- 質問内容のカスタマイズが自由
- 管理画面でリアルタイム集計可能

---

## 3. 動的アンケート設計（JSONB方式）

### 3.1 「質問を変更しやすい」設計の重要性

**誤解:** 「画面自作 = プログラムに質問を書き込む（ハードコード）」
**真実:** **Supabaseの「JSONB型」を使えば、Google Formsのように「管理画面から質問を自由に入れ替える」仕組みを簡単に作れます。**

### 3.2 Google Formsとの「質問変更」観点での再比較

| 観点 | Google Forms | 画面自作（JSONB動的生成） |
|------|--------------|--------------------------|
| **質問の追加・変更** | ブラウザ上でマウス操作（楽） | Supabase画面でJSONを書き換え（慣れれば楽） |
| **変更後のデータ整合性** | ⚠️ 以前のデータと列がズレて集計が大変 | ✅ 最強。`survey_id` で過去の回答と区別して保存できる |
| **条件分岐** | ✅ 「はい」と答えたらQ2へ、などが可能 | ⚠️ 少し実装が必要（工数増） |
| **即時報酬連携** | ❌ 不可能に近い | ✅ 容易。どんな質問内容になっても「送信完了」の瞬間にスタンプを付与できる |

### 3.3 質問マスタをDBで作る（動的設計）

質問項目を**コードに書くのではなく、DBに「今出したい質問リスト」を保存**しておきます。

#### `surveys` テーブルの設計例

| カラム名 | 型 | 説明 |
|---------|---|------|
| `id` | TEXT | アンケートのID（例: `satisfaction_2026Q1`） |
| `is_active` | BOOLEAN | `true` にしているものだけをアプリに表示 |
| `title` | TEXT | 「2月の満足度調査」など |
| **`questions`** | **JSONB** | **ここがキモ！質問の配列をまるごと入れる** |
| `reward_stamps` | INTEGER | 報酬スタンプ数（10倍整数） |

#### `questions` カラムの中身（JSON）のイメージ

```json
[
  {
    "id": "q1",
    "type": "stars",
    "label": "今日の治療の満足度は？",
    "required": true
  },
  {
    "id": "q2",
    "type": "choice",
    "label": "接客はどうでしたか？",
    "options": ["良い", "普通", "悪い"],
    "required": true
  },
  {
    "id": "q3",
    "type": "text",
    "label": "改善してほしい点はありますか？",
    "required": false
  },
  {
    "id": "q4",
    "type": "nps",
    "label": "当院を友人に勧めたいですか？",
    "min": 0,
    "max": 10,
    "required": true
  }
]
```

### 3.4 メリット：内容変更が「コード修正なし」で完結

この設計にすると、運用は以下のようになります:

1. **内容を変えたい時:**
   → Supabaseの管理画面（ダッシュボード）で、`questions` の中身を書き換えるだけ

2. **アプリの挙動:**
   → アプリを開いた瞬間に `is_active = true` のアンケートを取得し、その中身（JSON）を見て自動的に画面を生成します
   - `type: "stars"` なら星形アイコンを表示
   - `type: "choice"` なら選択肢ボタンを表示
   - `type: "text"` ならテキストエリアを表示
   - `type: "nps"` なら0-10のボタンを表示

3. **プログラムは1回組むだけ:**
   → 以降は質問内容を変えても**コード修正不要**

### 3.5 動的レンダリングの実装イメージ

```typescript
// questions の型に合わせて部品を出し分けるだけのシンプルなコード
{survey.questions.map((q) => (
  <div key={q.id} className="mb-6">
    <label className="font-bold mb-2">{q.label}</label>

    {/* 質問タイプごとにコンポーネントを切り替え */}
    {q.type === 'stars' && <StarRating id={q.id} />}
    {q.type === 'choice' && <RadioButtons options={q.options} />}
    {q.type === 'text' && <TextArea id={q.id} />}
    {q.type === 'nps' && <NPSScale id={q.id} min={q.min} max={q.max} />}
  </div>
))}
```

### 3.6 回答データの保存（柔軟なスキーマ）

#### 固定スキーマ方式（Phase 1）
```sql
-- Q1, Q2, Q3 が固定
create table survey_answers (
  id uuid primary key,
  user_id text,
  survey_id text,
  q1_rating integer,
  q2_comment text,
  q3_recommend integer,
  created_at timestamptz
);
```

#### 動的スキーマ方式（Phase 2以降）
```sql
-- 回答内容をJSONBで保存（どんな質問にも対応）
create table survey_answers (
  id uuid primary key,
  user_id text,
  survey_id text,
  answers jsonb,  -- {"q1": 5, "q2": "良かったです", "q3": 9}
  created_at timestamptz
);
```

**メリット:**
- ✅ 質問を追加/削除しても、テーブル構造を変更する必要がない
- ✅ `survey_id` で過去の回答と新しい回答を区別できる
- ✅ PostgreSQLの強力なJSONB検索機能を使って集計できる

**集計例:**
```sql
-- Q1（stars型）の評価分布
select
  answers->>'q1' as rating,
  count(*) as count
from survey_answers
where survey_id = 'satisfaction_2026Q1'
group by answers->>'q1';

-- Q3（choice型）の回答分布
select
  answers->>'q3' as choice,
  count(*) as count
from survey_answers
where survey_id = 'satisfaction_2026Q1'
group by answers->>'q3';
```

### 3.7 いつ「動的設計」に切り替えるべきか？

| 状況 | 推奨方式 |
|------|---------|
| **Phase 1（初回実装）** | 固定スキーマ（q1_rating, q2_comment, q3_recommend） |
| **Phase 2（複数アンケート）** | 動的スキーマ（answers JSONB） |
| **Phase 3（管理画面で質問作成）** | 完全動的設計（questions JSONB + answers JSONB） |

### 3.8 結論：どっちが「買い」か？

#### Google Formsが良いケース
- 「週に何度も、複雑な条件分岐（Q1でAならQ2へ、BならQ3へ…）があるアンケートを頻繁に変えたい」

#### 画面自作（JSONB動的設計）が良いケース
- 「月に1回程度、満足度調査の項目を入れ替えたり、特定のイベントへの感想を聞きたい」
- かつ **「答えた瞬間にスタンプを確実に、気持ちよくあげたい」**
- **「Supabase上のJSONをいじって、アプリの画面がパッと変わる」という体験を楽しみたい**

**ポイント:**
既に構築した「家族切り替え」のロジックに比べれば、この「JSONを読み取ってアンケートを表示する」ロジックは非常にシンプルで、かつ**「ミニアプリとしての完成度」が一段跳ね上がります。**

---

## 4. 機能要件

### 4.1 基本機能

| 機能 | 説明 |
|------|------|
| **アンケート表示** | LIFFアプリ内で専用ページを開く（例: `/survey/satisfaction`） |
| **回答送信** | ユーザーが選択肢を選んで「送信」ボタンをタップ |
| **重複回答防止** | 同じアンケートに対して1人1回まで（`user_id` + `survey_id` でユニーク制約） |
| **スタンプ付与** | 回答完了時に自動的にスタンプを加算（例: 3pt = 0.3個分） |
| **完了画面表示** | 「ありがとうございます！スタンプを3pt付与しました」と表示 |
| **ホームへ戻る** | 自動的にホーム画面に遷移 |

### 4.2 管理機能（将来実装）

| 機能 | 説明 |
|------|------|
| **回答集計** | 管理画面でアンケート結果を可視化（グラフ・表） |
| **CSV出力** | 回答データをCSV形式でダウンロード |
| **アンケート作成** | 管理画面から新しいアンケートを作成（将来拡張） |

---

## 4. データベース設計

### 4.1 テーブル設計

#### ① `survey_answers` テーブル（回答データ）

```sql
create table survey_answers (
  id uuid primary key default gen_random_uuid(),
  user_id text not null references profiles(id) on delete cascade,
  survey_id text not null,  -- 'satisfaction_2026Q1' などアンケート識別子
  q1_rating integer,        -- Q1: 5段階評価（1〜5）
  q2_comment text,          -- Q2: 自由記述
  q3_recommend integer,     -- Q3: 推奨度（0〜10）
  created_at timestamptz not null default now(),

  -- 重複回答防止
  unique(user_id, survey_id)
);

-- インデックス
create index idx_survey_answers_survey_id on survey_answers(survey_id);
create index idx_survey_answers_created_at on survey_answers(created_at);

-- RLSポリシー
alter table survey_answers enable row level security;

-- anon keyで全件参照・挿入可能（アプリ層でuser_idフィルタ）
create policy "anon_can_read_survey_answers"
  on survey_answers for select
  using (true);

create policy "anon_can_insert_survey_answers"
  on survey_answers for insert
  with check (true);

-- 管理者（SERVICE_ROLE）は全件参照可能（RLSバイパス）
-- ※ service_role key はRLSをバイパスするため、ポリシー不要
```

#### ② `surveys` テーブル（アンケート定義、将来拡張用）

##### Phase 1版（固定質問）
```sql
-- 将来的に複数アンケートを管理する場合
create table surveys (
  id text primary key,           -- 'satisfaction_2026Q1'
  title text not null,           -- 'ご利用満足度アンケート'
  description text,              -- 説明文
  reward_stamps integer not null default 3,  -- 報酬スタンプ数（10倍整数）
  is_active boolean not null default true,   -- 公開中かどうか
  start_date timestamptz,        -- 公開開始日
  end_date timestamptz,          -- 公開終了日
  created_at timestamptz not null default now()
);

-- 初回データ
insert into surveys (id, title, description, reward_stamps) values
  ('satisfaction_2026Q1', 'ご利用満足度アンケート', '当院のサービスについてお聞かせください', 3);
```

##### Phase 2版（動的質問 - JSONB方式）
```sql
create table surveys (
  id text primary key,
  title text not null,
  description text,
  questions jsonb not null,      -- 質問の配列をJSON形式で保存
  reward_stamps integer not null default 3,
  is_active boolean not null default true,
  start_date timestamptz,
  end_date timestamptz,
  created_at timestamptz not null default now()
);

-- 動的アンケートの例
insert into surveys (id, title, description, questions, reward_stamps) values
(
  'satisfaction_2026Q1',
  'ご利用満足度アンケート',
  '当院のサービスについてお聞かせください',
  '[
    {"id": "q1", "type": "stars", "label": "当院の対応に満足していますか？", "required": true},
    {"id": "q2", "type": "text", "label": "ご意見・ご感想（任意）", "required": false},
    {"id": "q3", "type": "nps", "label": "当院を友人に勧めたいですか？", "min": 0, "max": 10, "required": true}
  ]'::jsonb,
  3
);
```

### 4.2 データ保持期間

- **回答データ:** 原則として永久保存（マーケティング分析用）
- **個人情報削除依頼:** ユーザー削除時に `on delete cascade` で自動削除

---

## 5. 画面設計

### 5.1 アンケート画面（`/survey/satisfaction`）

#### レイアウト
```
┌─────────────────────────────────┐
│ 🏥 ご利用満足度アンケート         │
├─────────────────────────────────┤
│                                 │
│ 当院のサービスについて           │
│ お聞かせください                 │
│                                 │
│ ✅ 回答いただくと                │
│    スタンプ0.3個（3pt）プレゼント！│
│                                 │
├─────────────────────────────────┤
│ Q1. 当院の対応に満足していますか？│
│                                 │
│ ⭐️⭐️⭐️⭐️⭐️                    │
│ (5段階評価: タップで選択)         │
│                                 │
├─────────────────────────────────┤
│ Q2. ご意見・ご感想（任意）        │
│ ┌───────────────────────────┐   │
│ │                           │   │
│ │ (自由記述テキストエリア)    │   │
│ │                           │   │
│ └───────────────────────────┘   │
│                                 │
├─────────────────────────────────┤
│ Q3. 当院を友人に勧めたいですか？  │
│ (0: まったく勧めない 〜 10: ぜひ勧める) │
│                                 │
│ 0  1  2  3  4  5  6  7  8  9  10│
│ (ボタンで選択)                   │
│                                 │
├─────────────────────────────────┤
│                                 │
│      [ 送信する ]                │
│                                 │
└─────────────────────────────────┘
```

#### デザイン指針
- **既存のスタンプページと統一感を持たせる**
- カラー: `#4CAF50`（既存のプライマリカラー）
- フォント: `Noto Sans JP`
- ボタン: 既存の `Button` コンポーネントを再利用

### 5.2 完了画面（送信後）

```
┌─────────────────────────────────┐
│        ✅ 送信完了！             │
├─────────────────────────────────┤
│                                 │
│   ご回答ありがとうございます！    │
│                                 │
│   🎁 スタンプを0.3個（3pt）       │
│      付与しました！               │
│                                 │
│   (2秒後に自動的にホームへ戻ります) │
│                                 │
└─────────────────────────────────┘
```

### 5.3 既に回答済みの場合

```
┌─────────────────────────────────┐
│   ⚠️ 回答済みです                │
├─────────────────────────────────┤
│                                 │
│ このアンケートは既に回答済みです。│
│ ご協力ありがとうございました！    │
│                                 │
│      [ ホームへ戻る ]             │
│                                 │
└─────────────────────────────────┘
```

---

## 6. 実装フロー

### 6.1 ファイル構成

```
app/
├── survey/
│   └── [surveyId]/
│       └── page.tsx          # アンケート画面（例: /survey/satisfaction）
├── api/
│   └── survey/
│       ├── submit/
│       │   └── route.ts      # 回答送信API
│       └── check/
│           └── route.ts      # 回答済みチェックAPI
components/
├── survey/
│   ├── SurveyForm.tsx        # アンケートフォームコンポーネント
│   ├── StarRating.tsx        # 星評価コンポーネント
│   ├── NPSScale.tsx          # 0-10スケールコンポーネント
│   └── SurveyCompleted.tsx   # 完了画面コンポーネント
```

### 6.2 実装手順

#### ① データベースマイグレーション

**`supabase/017_create_survey_tables.sql`**
```sql
-- survey_answers テーブル作成
create table survey_answers (
  id uuid primary key default gen_random_uuid(),
  user_id text not null references profiles(id) on delete cascade,
  survey_id text not null,
  q1_rating integer,
  q2_comment text,
  q3_recommend integer,
  created_at timestamptz not null default now(),
  unique(user_id, survey_id)
);

create index idx_survey_answers_survey_id on survey_answers(survey_id);
create index idx_survey_answers_created_at on survey_answers(created_at);

alter table survey_answers enable row level security;

-- anon keyで全件参照・挿入可能（アプリ層でuser_idフィルタ）
create policy "anon_can_read_survey_answers"
  on survey_answers for select
  using (true);

create policy "anon_can_insert_survey_answers"
  on survey_answers for insert
  with check (true);

-- surveys テーブル作成（将来拡張用）
create table surveys (
  id text primary key,
  title text not null,
  description text,
  reward_stamps integer not null default 3,
  is_active boolean not null default true,
  start_date timestamptz,
  end_date timestamptz,
  created_at timestamptz not null default now()
);

-- 初回データ
insert into surveys (id, title, description, reward_stamps) values
  ('satisfaction_2026Q1', 'ご利用満足度アンケート', '当院のサービスについてお聞かせください', 3);
```

#### ② API実装

**`app/api/survey/submit/route.ts`**
```typescript
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
  try {
    const supabase = createRouteHandlerClient({ cookies });

    // 認証チェック
    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { surveyId, q1Rating, q2Comment, q3Recommend } = body;

    // プロフィール取得
    const { data: profile } = await supabase
      .from('profiles')
      .select('id')
      .eq('line_user_id', session.user.id)
      .single();

    if (!profile) {
      return NextResponse.json({ error: 'Profile not found' }, { status: 404 });
    }

    // 回答を保存
    const { error: insertError } = await supabase
      .from('survey_answers')
      .insert({
        user_id: profile.id,
        survey_id: surveyId,
        q1_rating: q1Rating,
        q2_comment: q2Comment,
        q3_recommend: q3Recommend,
      });

    if (insertError) {
      // 重複エラー（既に回答済み）
      if (insertError.code === '23505') {
        return NextResponse.json({ error: 'Already answered' }, { status: 409 });
      }
      throw insertError;
    }

    // スタンプ付与: stamp_history に追加（トリガーで profiles.stamp_count が自動更新）
    const { data: currentProfile } = await supabase
      .from('profiles')
      .select('stamp_count')
      .eq('id', profile.id)
      .single();

    const { error: stampError } = await supabase
      .from('stamp_history')
      .insert({
        user_id: profile.id,
        visit_date: new Date().toISOString(),
        stamp_number: (currentProfile?.stamp_count || 0) + 3,
        amount: 3,
        stamp_method: 'survey_reward',
        notes: `アンケート回答: ${surveyId}`,
      });

    if (stampError) throw stampError;

    // イベントログ記録
    await supabase.from('event_logs').insert({
      user_id: profile.id,
      event_name: 'survey_completed',
      source: 'app',
      metadata: { survey_id: surveyId },
    });

    return NextResponse.json({ success: true, stampsAdded: 3 });
  } catch (error) {
    console.error('Survey submit error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

**`app/api/survey/check/route.ts`**
```typescript
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function GET(request: Request) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { searchParams } = new URL(request.url);
    const surveyId = searchParams.get('surveyId');

    if (!surveyId) {
      return NextResponse.json({ error: 'surveyId required' }, { status: 400 });
    }

    const { data: { session } } = await supabase.auth.getSession();
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('id')
      .eq('line_user_id', session.user.id)
      .single();

    if (!profile) {
      return NextResponse.json({ error: 'Profile not found' }, { status: 404 });
    }

    // 回答済みチェック
    const { data: answer } = await supabase
      .from('survey_answers')
      .select('id')
      .eq('user_id', profile.id)
      .eq('survey_id', surveyId)
      .single();

    return NextResponse.json({ hasAnswered: !!answer });
  } catch (error) {
    console.error('Survey check error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

#### ③ フロントエンド実装

**`app/survey/[surveyId]/page.tsx`**
```typescript
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import SurveyForm from '@/components/survey/SurveyForm';
import SurveyCompleted from '@/components/survey/SurveyCompleted';

export default function SurveyPage({ params }: { params: { surveyId: string } }) {
  const router = useRouter();
  const [hasAnswered, setHasAnswered] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    checkIfAnswered();
  }, []);

  const checkIfAnswered = async () => {
    try {
      const res = await fetch(`/api/survey/check?surveyId=${params.surveyId}`);
      const data = await res.json();
      setHasAnswered(data.hasAnswered);
    } catch (error) {
      console.error('Failed to check survey status:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = async (answers: any) => {
    try {
      const res = await fetch('/api/survey/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          surveyId: params.surveyId,
          ...answers,
        }),
      });

      if (res.ok) {
        setIsCompleted(true);
        // 2秒後にホームへ戻る
        setTimeout(() => router.push('/'), 2000);
      } else {
        const error = await res.json();
        alert(error.error || '送信に失敗しました');
      }
    } catch (error) {
      console.error('Survey submit error:', error);
      alert('送信に失敗しました');
    }
  };

  if (loading) {
    return <div className="p-4">読み込み中...</div>;
  }

  if (hasAnswered) {
    return (
      <div className="p-4 text-center">
        <h2 className="text-xl font-bold mb-4">⚠️ 回答済みです</h2>
        <p className="mb-4">このアンケートは既に回答済みです。</p>
        <p className="mb-6">ご協力ありがとうございました！</p>
        <button
          onClick={() => router.push('/')}
          className="px-6 py-2 bg-green-600 text-white rounded-lg"
        >
          ホームへ戻る
        </button>
      </div>
    );
  }

  if (isCompleted) {
    return <SurveyCompleted />;
  }

  return <SurveyForm onSubmit={handleSubmit} />;
}
```

**`components/survey/SurveyForm.tsx`**
```typescript
'use client';

import { useState } from 'react';
import StarRating from './StarRating';
import NPSScale from './NPSScale';

interface SurveyFormProps {
  onSubmit: (answers: any) => void;
}

export default function SurveyForm({ onSubmit }: SurveyFormProps) {
  const [q1Rating, setQ1Rating] = useState<number>(0);
  const [q2Comment, setQ2Comment] = useState<string>('');
  const [q3Recommend, setQ3Recommend] = useState<number | null>(null);

  const handleSubmit = () => {
    if (q1Rating === 0) {
      alert('Q1の評価を選択してください');
      return;
    }
    if (q3Recommend === null) {
      alert('Q3の推奨度を選択してください');
      return;
    }

    onSubmit({
      q1Rating,
      q2Comment,
      q3Recommend,
    });
  };

  return (
    <div className="p-4 max-w-md mx-auto">
      <h1 className="text-2xl font-bold mb-2">🏥 ご利用満足度アンケート</h1>
      <p className="text-sm text-gray-600 mb-4">当院のサービスについてお聞かせください</p>

      <div className="bg-green-50 p-3 rounded-lg mb-6">
        <p className="text-sm text-green-800">
          ✅ 回答いただくとスタンプ0.3個（3pt）プレゼント！
        </p>
      </div>

      {/* Q1: 5段階評価 */}
      <div className="mb-6">
        <h3 className="font-bold mb-2">Q1. 当院の対応に満足していますか？</h3>
        <StarRating value={q1Rating} onChange={setQ1Rating} />
      </div>

      {/* Q2: 自由記述 */}
      <div className="mb-6">
        <h3 className="font-bold mb-2">Q2. ご意見・ご感想（任意）</h3>
        <textarea
          value={q2Comment}
          onChange={(e) => setQ2Comment(e.target.value)}
          placeholder="ご自由にお書きください"
          className="w-full p-3 border rounded-lg"
          rows={4}
        />
      </div>

      {/* Q3: NPS（推奨度） */}
      <div className="mb-6">
        <h3 className="font-bold mb-2">Q3. 当院を友人に勧めたいですか？</h3>
        <p className="text-xs text-gray-600 mb-2">
          0: まったく勧めない 〜 10: ぜひ勧める
        </p>
        <NPSScale value={q3Recommend} onChange={setQ3Recommend} />
      </div>

      <button
        onClick={handleSubmit}
        className="w-full py-3 bg-green-600 text-white rounded-lg font-bold text-lg"
      >
        送信する
      </button>
    </div>
  );
}
```

**`components/survey/StarRating.tsx`**
```typescript
'use client';

interface StarRatingProps {
  value: number;
  onChange: (value: number) => void;
}

export default function StarRating({ value, onChange }: StarRatingProps) {
  return (
    <div className="flex gap-2 justify-center">
      {[1, 2, 3, 4, 5].map((star) => (
        <button
          key={star}
          onClick={() => onChange(star)}
          className="text-4xl transition-transform hover:scale-110"
        >
          {star <= value ? '⭐️' : '☆'}
        </button>
      ))}
    </div>
  );
}
```

**`components/survey/NPSScale.tsx`**
```typescript
'use client';

interface NPSScaleProps {
  value: number | null;
  onChange: (value: number) => void;
}

export default function NPSScale({ value, onChange }: NPSScaleProps) {
  return (
    <div className="flex flex-wrap gap-2 justify-center">
      {[...Array(11)].map((_, i) => (
        <button
          key={i}
          onClick={() => onChange(i)}
          className={`w-10 h-10 rounded-lg font-bold transition-all ${
            value === i
              ? 'bg-green-600 text-white scale-110'
              : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
          }`}
        >
          {i}
        </button>
      ))}
    </div>
  );
}
```

**`components/survey/SurveyCompleted.tsx`**
```typescript
'use client';

export default function SurveyCompleted() {
  return (
    <div className="p-4 max-w-md mx-auto text-center">
      <div className="mb-4">
        <div className="text-6xl mb-4">✅</div>
        <h2 className="text-2xl font-bold mb-2">送信完了！</h2>
      </div>

      <p className="text-lg mb-4">ご回答ありがとうございます！</p>

      <div className="bg-green-50 p-4 rounded-lg mb-4">
        <p className="text-green-800 font-bold">
          🎁 スタンプを0.3個（3pt）付与しました！
        </p>
      </div>

      <p className="text-sm text-gray-600">
        2秒後に自動的にホームへ戻ります
      </p>
    </div>
  );
}
```

---

## 7. スタンプ付与ロジック

### 7.1 10倍整数ルール

既存の仕様に合わせて、**10倍整数**でスタンプを管理:

```typescript
// 0.3個分のスタンプを付与 → 3pt
await supabase.rpc('increment_stamp', {
  row_id: profile.id,
  amount: 3,
});
```

### 7.2 スタンプ数の設定変更

`surveys` テーブルの `reward_stamps` カラムで調整可能:

```sql
-- アンケートAは0.3個（3pt）
update surveys set reward_stamps = 3 where id = 'satisfaction_2026Q1';

-- アンケートBは0.5個（5pt）
update surveys set reward_stamps = 5 where id = 'satisfaction_2026Q2';
```

---

## 8. 管理画面での集計

### 8.1 集計SQL例

#### 回答数の推移
```sql
select
  date_trunc('day', created_at) as date,
  count(*) as answer_count
from survey_answers
where survey_id = 'satisfaction_2026Q1'
group by date
order by date desc;
```

#### Q1の評価分布
```sql
select
  q1_rating,
  count(*) as count,
  round(count(*) * 100.0 / sum(count(*)) over (), 1) as percentage
from survey_answers
where survey_id = 'satisfaction_2026Q1'
group by q1_rating
order by q1_rating desc;
```

#### Q3のNPS計算
```sql
-- NPS = (推奨者% - 批判者%) の計算
-- 推奨者: 9-10点、中立者: 7-8点、批判者: 0-6点
select
  count(case when q3_recommend >= 9 then 1 end) * 100.0 / count(*) as promoters_pct,
  count(case when q3_recommend <= 6 then 1 end) * 100.0 / count(*) as detractors_pct,
  count(case when q3_recommend >= 9 then 1 end) * 100.0 / count(*) -
    count(case when q3_recommend <= 6 then 1 end) * 100.0 / count(*) as nps
from survey_answers
where survey_id = 'satisfaction_2026Q1';
```

#### 自由記述の一覧
```sql
select
  p.real_name,
  sa.q2_comment,
  sa.created_at
from survey_answers sa
join profiles p on sa.user_id = p.id
where sa.survey_id = 'satisfaction_2026Q1'
  and sa.q2_comment is not null
  and sa.q2_comment != ''
order by sa.created_at desc;
```

### 8.2 管理画面ビュー作成（将来）

```sql
-- アンケート結果サマリービュー
create view survey_summary as
select
  s.id as survey_id,
  s.title as survey_title,
  count(sa.id) as total_answers,
  avg(sa.q1_rating) as avg_rating,
  avg(sa.q3_recommend) as avg_nps_score,
  count(case when sa.q3_recommend >= 9 then 1 end) * 100.0 / count(*) -
    count(case when sa.q3_recommend <= 6 then 1 end) * 100.0 / count(*) as nps
from surveys s
left join survey_answers sa on s.id = sa.survey_id
group by s.id, s.title;
```

---

## 9. 今後の拡張性

### 9.1 Phase 1（現在）
- ✅ 基本的なアンケート機能
- ✅ 固定3問（5段階評価、自由記述、NPS）
- ✅ 回答送信 + スタンプ付与
- ✅ 重複回答防止

### 9.2 Phase 2（将来）
- 📋 管理画面でアンケート結果の可視化
- 📋 CSV出力機能
- 📋 複数アンケートの並行実施

### 9.3 Phase 3（将来）
- 📋 **動的アンケート作成機能（管理画面で質問を追加/削除）** ← JSONB方式で実現
- 📋 条件分岐（Q1で「不満」を選んだ人だけQ2に進む、など）
- 📋 回答期限設定（`surveys.end_date`）
- 📋 特定ユーザーへのアンケート配信（LINEメッセージからの誘導）

### 9.4 JSONB動的設計の追加メリット
- ✅ **質問内容の変更がコード修正不要**
- ✅ **過去のアンケートと新しいアンケートの回答を綺麗に分離**
- ✅ **PostgreSQLの強力なJSONB検索で柔軟な集計が可能**
- ✅ **Google Formsのような「変更しやすさ」と、自作ならではの「スタンプ付与・デザイン統一」の両立**

---

## 10. LINE連携（アンケート配信）

### 10.1 LINEメッセージからの誘導

**Messaging API で送信するメッセージ例:**
```json
{
  "type": "flex",
  "altText": "ご利用満足度アンケートのお願い",
  "contents": {
    "type": "bubble",
    "body": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        {
          "type": "text",
          "text": "📋 アンケートのお願い",
          "weight": "bold",
          "size": "xl"
        },
        {
          "type": "text",
          "text": "当院のサービスについてお聞かせください",
          "size": "sm",
          "color": "#666666",
          "wrap": true
        },
        {
          "type": "text",
          "text": "✅ 回答でスタンプ0.3個プレゼント！",
          "size": "sm",
          "color": "#00B900",
          "weight": "bold",
          "margin": "md"
        }
      ]
    },
    "footer": {
      "type": "box",
      "layout": "vertical",
      "contents": [
        {
          "type": "button",
          "action": {
            "type": "uri",
            "label": "アンケートに回答する",
            "uri": "https://liff.line.me/YOUR_LIFF_ID/survey/satisfaction_2026Q1"
          },
          "style": "primary",
          "color": "#4CAF50"
        }
      ]
    }
  }
}
```

### 10.2 イベントログとの連携

アンケート配信の効果測定:
```sql
-- LINE配信後のアプリ起動率
select
  date_trunc('day', created_at) as date,
  count(distinct user_id) as users_opened
from event_logs
where event_name = 'app_open'
  and source = 'line_msg_survey_0225'
  and created_at >= '2026-02-25'
group by date;

-- アンケート回答率
select
  count(distinct el.user_id) as users_opened,
  count(distinct sa.user_id) as users_answered,
  round(count(distinct sa.user_id) * 100.0 / count(distinct el.user_id), 1) as conversion_rate
from event_logs el
left join survey_answers sa on el.user_id = sa.user_id and sa.survey_id = 'satisfaction_2026Q1'
where el.event_name = 'app_open'
  and el.source = 'line_msg_survey_0225'
  and el.created_at >= '2026-02-25';
```

---

## 11. セキュリティ・プライバシー考慮事項

### 11.1 個人情報保護
- ✅ 自由記述（Q2）は個人を特定できる情報を含まないよう注意喚起
- ✅ 管理画面では匿名化オプション（実名を隠す）を提供（将来）

### 11.2 RLSポリシー
- ✅ ユーザーは自分の回答のみ参照可能
- ✅ 挿入も自分のuser_idのみ可能
- ✅ 管理者はSERVICE_ROLEで全件参照（管理画面用）

### 11.3 重複回答防止
- ✅ `unique(user_id, survey_id)` 制約
- ✅ 既に回答済みの場合は「回答済みです」画面を表示

---

## 12. まとめ

### 12.1 採用方式
**「画面自作（Next.js + Supabase）」** を採用

### 12.2 理由
1. **最高のUX**: アプリ内で完結、別タブに飛ばない
2. **既存システムとの親和性**: Next.js + Supabase、スタンプ付与ロジック再利用
3. **回答率の最大化**: 「1タップで完結」
4. **将来の拡張性**: 複数アンケート、動的作成、管理画面での集計

### 12.3 実装スケジュール目安

| フェーズ | 内容 | 工数 |
|---------|------|------|
| **Phase 1（固定質問）** | DB設計、API実装、画面実装（q1/q2/q3固定） | 2〜3日 |
| **Phase 2（動的質問）** | JSONB方式への移行、動的レンダリング実装 | 1〜2日 |
| **Phase 3（管理画面）** | 集計表示、CSV出力、質問作成UI | 3〜5日 |

**推奨アプローチ:**
- 初回は**Phase 1（固定質問）**で実装してリリース
- ユーザー反応を見て、複数アンケートが必要になったら**Phase 2（動的質問）**に移行
- 運用が軌道に乗ったら**Phase 3（管理画面）**で完全自動化

### 12.4 期待効果
- 📈 患者満足度の定量的把握
- 📈 LINE配信効果測定（開封率・回答率）
- 📈 エンゲージメント向上（スタンプ付与によるインセンティブ）
- 📈 離脱ポイントの特定（どの機能が使われていないか）

---

**最終更新:** 2026-02-25
**次のステップ:** Phase 1実装開始（DB設計 → API → 画面）
