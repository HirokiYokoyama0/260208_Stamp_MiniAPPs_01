# 実装サマリー

各日の実装内容を時系列で記録。新しい作業はこのファイルの末尾に追記する。

---

## 2026-02-08: Phase 1 バックエンド基盤構築

### Supabase連携実装
- @supabase/supabase-js インストール、lib/supabase.ts 作成
- .env.local に SUPABASE_URL, SUPABASE_ANON_KEY 設定

### データベース設計
- profilesテーブル作成（001_create_profiles_table.sql）
- id を TEXT型（LINEユーザーID直接格納）で設計
- RLS設定、インデックス作成

### ユーザー情報の自動保存
- LINEログイン時に profiles へ UPSERT（id, line_user_id, display_name, picture_url）
- updated_at を自動更新

### 画面表示機能
- スタンプ数（stamp_count）のリアルタイム表示
- 診察券番号（ticket_number）表示（未登録時は「未登録」）
- 最終アクセス日時（updated_at）を日本語フォーマットで表示

### セキュリティ対応
- Next.js 15.1.0 → 16.1.6（CVE-2025-66478 脆弱性対応）
- React 19.0.0 → 19.2.4
- .gitignore に .claude, .env.local 追加

---

## 2026-02-09: Phase 2 スタンプ機能 + Phase 2.5 特典交換システム

### データベース拡張

**stamp_historyテーブル（002_create_stamp_history_table.sql）:**
- 1ユーザー:N個のスタンプ（1:N関係）
- QRコードIDで重複防止
- トリガー関数 `update_profile_stamp_count()` で profiles.stamp_count を自動計算

**rewards / reward_exchangesテーブル（003_create_rewards_tables.sql）:**
- rewards: 特典マスター（歯ブラシセット5個、フッ素塗布10個、クリーニング半額15個、ホワイトニング30%OFF 20個）
- reward_exchanges: 交換履歴（status: pending/completed/cancelled）

### データアーキテクチャ: Single Source of Truth
- profiles.stamp_count がスタンプ数の唯一の真実
- stamp_history INSERT → トリガー → profiles.stamp_count 自動更新
- 診察券ページとスタンプページでデータ不整合なし

### スタンプ登録API
- POST /api/stamps: QRスキャン → stamp_history INSERT → 重複チェック（同日同QR）
- lib/stamps.ts: fetchStampCount, fetchStampHistory, addStamp 等
- types/stamp.ts: StampHistoryRecord, AddStampResponse, StampProgress

### スタンプページ完全実装（app/stamp/page.tsx）
- スタンプカウンター、プログレスバー、来院履歴リスト、QRスキャン

### 特典交換システム
- GET /api/rewards: 有効な特典一覧取得
- POST /api/rewards/exchange: スタンプ積み上げ式（スタンプは減らない）
- app/rewards/page.tsx: 特典一覧、交換可否判定、交換処理
- lib/rewards.ts, types/reward.ts

### ボトムナビゲーション拡張
- 4つ → 5つ（診察券/スタンプ/特典/ケア記録/医院情報）
- アイコン20px、ラベル10px、flex-1でタップ領域均等配分

### スタッフ手動スタンプ機能強化
- 2ステップUI（認証 → 編集）、+/-ボタン
- POST /api/stamps/manual: newStampCount パラメータ追加
- 1日1回制限解除、監査証跡を stamp_history に記録

### バージョン管理自動化
- scripts/update-version.mjs: Gitタグから自動バージョン取得
- next.config.mjs: NEXT_PUBLIC_APP_VERSION として埋め込み
- prebuild フックで package.json を自動更新

### 仕様変更（v1.1）
- スタンプ消費型 → 積み上げ式に変更（2026-02-09）
- 条件を満たせば何度でも特典交換可能

---

## 2026-02-09: LINE友だち登録機能

### データベース
- profiles.is_line_friend カラム追加（004_add_is_line_friend_column.sql）
- BOOLEAN型、デフォルト NULL（未確認）

### 実装
- hooks/useLiff.ts: liff.getFriendship() で友だち状態取得、Supabaseにキャッシュ
- components/features/FriendshipPromptModal.tsx: 友だち登録促進モーダル
- AppLayout.tsx: 初回起動時にモーダル表示（1日1回、2秒遅延）
- AdultInfoPage.tsx: 友だち登録状態に応じた表示切替
- 友だち追加URL: https://line.me/R/ti/p/@550mlcao

---

## 2026-02-11: 子供用モード基盤（Kids Mode Phase 1）

### フォルダ構成リファクタリング
- 既存ページUIを components/(adult)/AdultXxx.tsx に抽出（5ファイル）
- components/(kids)/KidsXxx.tsx をプレースホルダーとして作成（5ファイル）
- QRScanner, StaffPinModal を features/ → shared/ に移動

### ViewModeContext（表示モード管理）
- contexts/ViewModeContext.tsx: adult/kids 切替、Supabase profiles.view_mode と同期
- types/viewMode.ts: ViewMode 型定義
- デフォルト 'adult'、エラー時もクラッシュしない

### ページルーティング変更
- 全5ページを共通パターンに書き換え: useViewMode() → Adult/Kids 分岐

### 設定ページ
- app/settings/page.tsx: 大人用/子供用モード切替ボタン

### Tailwind CSS拡張
- kids カラー5色: kids-pink, kids-yellow, kids-green, kids-blue, kids-purple
- kids フォント: "M PLUS Rounded 1c"

### Supabaseマイグレーション
- 005_add_view_mode_column.sql: profiles.view_mode カラム追加

### 子供用医院情報ページ
- KidsInfoPage.tsx: 全セクションひらがな表記、kidsカラー5色で色分け
- 設定ページへのリンク（モード切替用）

### ハブラーシカ画像
- public/images/haburashika.jpg に配置
- KidsStampPage で使用（120x120）

### 子供用スロットゲームボタン
- components/shared/KidsSlotButton.tsx: 子供モード時のみフローティング表示
- app/slot/page.tsx: プレースホルダー
- ボトムナビ左上に固定配置（bottom-[72px] left-4）

### その他
- 設定ページの alert() 削除
- ファイル構成.md 全面更新

### デプロイ注意
- 推奨順: SQL（005）→ Vercelデプロイ
- 逆順でもクラッシュしないが、設定ページのモード切替が機能しない

---

## 2026-02-12: テスト環境構築 / Doc整理

### LIFF環境分離（本番 / テスト）
- **本番用（Vercel）**: `NEXT_PUBLIC_LIFF_ID=2009075851-74EieWb4`
- **テスト用（ngrok）**: `NEXT_PUBLIC_LIFF_ID=2009075851-kflzDQLr`
- `.env.local` でコメントアウト切替で管理
- テスト時は ngrok で `https://xxx.ngrok-free.dev` → `localhost:3000` にトンネル

### ngrok導入
- winget でインストール（v3.36.0）
- authtoken 設定済み

### Doc フォルダ整理
- Implementation_Summary 3ファイル → 1ファイルに統合（追記型）
- Feature_Specifications 4ファイル → 1ファイルに統合（スタンプ/特典/スタッフ操作/友だち登録）
- 10ファイルを Doc/archive/ に移動
- Doc直下: 15ファイル → 7ファイル + archive に集約
- ファイル構成.md を新構成に更新

---

## 2026-02-14: 次回メモ機能実装

### 概要
受付スタッフが患者ごとに「次回来院予定日」と「カスタムメッセージ」を設定できる機能。患者のLINEミニアプリのホーム画面に表示される。

### データベース実装
**マイグレーション（006_add_next_memo_columns.sql）:**
- profiles テーブルに3つのカラム追加：
  - `next_visit_date` (DATE): 次回来院予定日
  - `next_memo` (TEXT): カスタムメッセージ（最大200文字）
  - `next_memo_updated_at` (TIMESTAMPTZ): 最終更新日時
- 部分インデックス作成（next_visit_date が NULL でない行のみ）
- 自動更新トリガー追加：
  - `update_next_memo_timestamp()` 関数: next_visit_date または next_memo 変更時に next_memo_updated_at を自動更新
  - `trigger_update_next_memo_timestamp` トリガー: BEFORE UPDATE で実行

### API実装
**新規エンドポイント:**
- `GET /api/users/[userId]/memo`: ユーザーの次回メモを取得
- `PUT /api/users/[userId]/memo`: ユーザーの次回メモを更新
  - バリデーション: 日付形式（YYYY-MM-DD）、文字数制限（200文字）

**ファイル:**
- `app/api/users/[userId]/memo/route.ts`: API実装
- `types/memo.ts`: 型定義（UserMemo, UpdateUserMemoRequest, UpdateUserMemoResponse）
- `lib/memo.ts`: ヘルパー関数（fetchUserMemo, updateUserMemo, formatVisitDate）

### フロントエンド実装
**患者側表示（AdultHome.tsx）:**
- ハブラーシカメッセージセクションの内容を動的に生成
- 4つの表示パターン：
  1. 日付あり + メモあり: 「次回の定期検診は○年○月○日です。<br>カスタムメッセージ」
  2. 日付あり + メモなし: 「次回の定期検診は○年○月○日です。」
  3. 日付なし + メモあり: 「カスタムメッセージ」のみ
  4. どちらもなし: デフォルトメッセージ
- データ取得: ログイン時、スタンプ獲得後、特典交換後に自動取得

**管理画面（/admin/memo）:**
- 簡易編集画面を作成（Phase 7で本格管理画面に統合予定）
- 入力項目:
  - ユーザーID（LINE User ID）
  - 次回来院予定日（日付ピッカー）
  - カスタムメッセージ（テキストエリア、200文字制限）
- リアルタイムプレビュー機能
- 保存 / クリアボタン

### 技術的な改善
**タイムゾーン問題の修正:**
- `new Date("2026-04-13")` はタイムゾーンによって前日になる問題を修正
- 文字列を直接分解する方式に変更: `split('-').map(Number)`
- lib/memo.ts の `formatVisitDate()` 関数で実装

**バリデーション強化:**
- API側で200文字制限を強制（app/api/users/[userId]/memo/route.ts:120-135）
- フロントエンドだけでなくバックエンドでも検証

**自動更新トリガー:**
- next_memo_updated_at の手動更新が不要に
- データベーストリガーで自動管理

### セキュリティ
- 現状は認証なしの簡易管理画面（/admin/memo）
- Phase 7で本格的なスタッフ認証を実装予定
- 本番環境ではIP制限またはBasic認証を推奨

### ドキュメント更新
- 03_機能仕様書.md: 5章「次回メモ機能」を追加
- 90_実装履歴.md: 本セクションを追加
- 10_TODO.md: 次回メモ機能を完了済みタスクに追加予定

### 将来の拡張案
- ユーザー検索機能（名前・診察券番号で検索）
- メッセージテンプレート機能
- 変数置換機能（{name}, {stamp_count} など）
- 一括設定機能（全患者向けお知らせ）
- LINE通知連携（予定日の3日前に自動通知）

---

## 2026-02-14: 予約ボタンクリック数トラッキング機能

### 概要
患者が「予約する」ボタンをクリックした回数を記録し、後から統計分析できるようにする機能。スタンプ数と予約ボタンクリック数の相関分析や、再来院促進施策の効果測定に活用する。

### 設計方針
**シンプル設計:**
- 単純な累積カウンター（履歴テーブルなし）
- profiles.reservation_button_clicks カラム（INTEGER）で管理
- 増加のみ（減少処理なし）

**UX優先:**
- エラーでもユーザー体験を妨げない
- fetch を await せず非同期で実行
- .catch() でエラーを握りつぶす（コンソールログのみ）

### データベース実装
**マイグレーション（007_add_reservation_clicks.sql）:**
- profiles テーブルに `reservation_button_clicks` カラム追加（INTEGER, DEFAULT 0）
- インデックス作成（idx_profiles_reservation_clicks）
- PostgreSQL関数 `increment_reservation_clicks(p_user_id TEXT)` を作成：
  - DECLARE ブロックで new_count 変数を宣言
  - COALESCE で NULL 安全な +1 処理
  - RETURNING 句で更新後の値を取得
  - ユーザーが存在しない場合は 0 を返す

### API実装
**新規エンドポイント:**
- `POST /api/users/[userId]/reservation-click`: クリック数を+1する
  - リクエストボディ: 空
  - レスポンス: { success: boolean, message: string, clicks?: number }
  - エラーハンドリング: 400（不正なユーザーID）、404（ユーザー未存在）、500（DB エラー）

**ファイル:**
- `app/api/users/[userId]/reservation-click/route.ts`: API実装
- supabase.rpc('increment_reservation_clicks', { p_user_id }) でDB関数を呼び出し

### フロントエンド実装
**AdultHome.tsx:**
- `handleReservation()` 関数に7行追加
- 予約ボタンクリック時、APIエンドポイントを呼び出し
- fetch を await せず非同期実行
- .catch() でエラーを握りつぶす（console.error のみ）

**実装コード:**
```typescript
// 🆕 予約ボタンのクリック数をカウント
if (profile?.userId) {
  fetch(`/api/users/${profile.userId}/reservation-click`, {
    method: "POST",
  }).catch((error) => {
    // エラーでもユーザー体験は妨げない
    console.error("⚠️ クリックカウントエラー:", error);
  });
}
```

### データ分析
**統計クエリ（機能仕様書に記載）:**
1. スタンプ数とクリック数の相関分析
2. クリック率でユーザー分類（高頻度/標準/低頻度）
3. 再来院率の計測（最終来院日ベース）
4. スタンプ段階別のクリック率

### 将来の拡張案
- クリック履歴テーブル追加（日時、デバイス情報などを記録）
- 予約完了フラグとの連携（クリック→実際に予約したかを追跡）
- A/Bテスト機能（ボタン文言やデザインの効果測定）
- プッシュ通知の効果測定（通知送信後のクリック増加率）

### ドキュメント更新
- 03_機能仕様書.md: 6章「予約ボタンクリック数トラッキング機能」を追加
- 90_実装履歴.md: 本セクションを追加
- 10_TODO.md: 予約ボタンクリック機能を完了済みタスクに追加

---

## 2026-02-17: Phase 2 家族紐付け機能実装完了

### 概要
親子で協力してスタンプを貯める「家族連携機能」を実装。初回登録時に親（保護者）または子（メンバー）を選択し、招待コードで家族に参加できる。

**実装期間**: 2026-02-17（1日で完了）

### データベース実装

**マイグレーション（009_add_family_support.sql）:**
- **familiesテーブル新規作成**:
  - id (TEXT, PRIMARY KEY): 家族ID（招待コードとして使用）
  - family_name (TEXT): 家族名
  - representative_user_id (TEXT): 代表者（親）のユーザーID
  - created_at, updated_at (TIMESTAMPTZ)
- **profilesテーブル拡張**:
  - family_id (TEXT, FOREIGN KEY → families.id)
  - family_role (TEXT): 'parent' または 'child'
  - CHECK制約で値を制限
- **family_stamp_totalsビュー**:
  - 家族ごとのスタンプ合計を自動集計
  - family_id, family_name, member_count, total_stamp_count, total_visit_count
- **トリガー関数**:
  - `update_families_updated_at()`: families.updated_at を自動更新
- **RLS ポリシー**:
  - すべて `USING (true)` に設定（APIレイヤーでアクセス制御）

**マイグレーション（009_fix_rls_policies.sql）:**
- `auth.uid()` を使用したRLSポリシーを削除
- 理由: LINE認証を使用しており、Supabase Authを使っていないため型エラーが発生
- 管理ダッシュボードからのアクセスも考慮

**型の統一（重要）:**
- `families.id` を UUID → TEXT に変更
- `profiles.id` が TEXT型（LINE User ID）のため、外部キー制約の型を統一
- UUID生成は `gen_random_uuid()::TEXT` で対応

### API実装（6本）

**1. GET /api/users/me:**
- ユーザー情報 + 家族情報を取得
- Supabaseの JOIN クエリで families テーブルも取得
- family_role が NULL の場合は /onboarding へリダイレクト

**2. POST /api/users/setup-role:**
- 初回登録時のロール設定
- 親の場合: 新規家族を自動作成（family_name: "〇〇の家族"）
- 子の場合: family_role のみ設定、/family/join へリダイレクト

**3. POST /api/families/join:**
- 子どもが招待コードで家族に参加
- inviteCode（families.id）で家族を検索
- profiles.family_id を更新

**4. GET /api/families/me:**
- 家族詳細 + メンバー一覧を取得
- family_stamp_totals ビューから家族合計スタンプを取得
- メンバーごとのスタンプ数・訪問回数も取得

**5. PATCH /api/families/update:**
- 家族名の変更（親専用）
- family_role === 'parent' のチェック
- families.family_name を更新

**6. DELETE /api/families/members:**
- メンバーの削除（親専用、子のみ削除可能）
- profiles.family_id を NULL に設定
- 親自身は削除不可

### UI実装（3ページ + 設定画面修正）

**1. app/onboarding/page.tsx（初回ロール選択画面）:**
- 親（User アイコン）/ 子（Baby アイコン）の2択ボタン
- useLiff() でLINEユーザー情報取得
- POST /api/users/setup-role でロール設定
- 親 → / へ、子 → /family/join へリダイレクト

**2. app/family/join/page.tsx（家族参加画面）:**
- 招待コード入力フィールド
- クリップボードから貼り付けボタン（navigator.clipboard.readText）
- POST /api/families/join で家族参加
- 成功時 → / へリダイレクト
- ヘルプセクション: 招待コードの取得方法を説明
- QRコード読み取りボタン（将来実装用、現在は disabled）

**3. app/family/manage/page.tsx（家族管理画面・親専用）:**
- 家族名のインライン編集（編集モード切替）
- 招待コードの表示 + コピーボタン
- メンバー一覧カード表示（display_name, スタンプ数, ロール）
- 子の削除ボタン（確認ダイアログ付き）
- calculateStampDisplay() で10倍システムに対応

**4. app/settings/page.tsx（設定画面修正）:**
- 「家族管理」セクションを追加
- Users アイコン付きボタン
- ロールに応じた説明文の出し分け:
  - parent: 「家族メンバーの管理や招待コードの確認」
  - child: 「家族への参加」
  - 未設定: 「家族機能を設定」
- クリック時の遷移先振り分け:
  - parent → /family/manage
  - child → /family/join
  - 未設定 → /onboarding

### テスト環境構築

**ローカル開発環境:**
- Next.js開発サーバー: ポート4000で起動
- ngrokトンネル: `npx ngrok http 4000`
- トンネルURL: https://vibrioid-jolyn-polyphonically.ngrok-free.dev
- LIFF設定: エンドポイントURLを更新（テスト用LIFF ID: 2009075851-kflzDQLr）

**デバッグログ追加:**
- `hooks/useLiff.ts`: LIFF初期化の各ステップにconsole.log追加
- `contexts/ViewModeContext.tsx`: プロフィール取得処理にログ追加
- ブラウザコンソールで動作確認が容易に

### トラブルシューティング履歴

**問題1: 型の不一致エラー（profiles.id vs families.id）**
- 症状: profiles.id は TEXT だが families.id が UUID で外部キー制約エラー
- 解決: families.id を TEXT に変更、gen_random_uuid()::TEXT で生成

**問題2: RLS ポリシーで auth.uid() 型エラー**
- 症状: auth.uid() は UUID を返すが profiles.id は TEXT
- 解決: RLS ポリシーを `USING (true)` に簡略化（APIレイヤーで制御）

**問題3: 管理ダッシュボードからのアクセス制限**
- 症状: 厳格なRLSポリシーだと管理画面から操作不可
- 解決: Service Role Key使用時は全アクセス可能に（`USING (true)`）

**問題4: Next.jsサーバー起動エラー（ロックファイル）**
- 症状: .next/dev/lock ファイルが残りポート4000で起動失敗
- 解決: 既存nodeプロセスを確認、適切に終了してから再起動

**問題5: ngrokが3000番ポートに接続**
- 症状: ngrokが意図しないポート（3000）に接続
- 解決: 明示的に `npx ngrok http 4000` で指定

### 技術的な設計判断

**1. TEXT型の採用理由:**
- LINE User IDがUUID形式ではない（"U" + 32文字の英数字）
- 一貫性のため families.id も TEXT 型に統一
- 招待コードとしても利用（そのまま表示可能）

**2. RLS ポリシーの簡略化:**
- LINE認証を使用（Supabase Authは未使用）
- 管理ダッシュボードでのアクセスも必要
- アクセス制御はAPIレイヤーで実装（family_role チェック）

**3. 積み上げ式スタンプシステムとの整合性:**
- family_stamp_totals ビューで自動集計
- メンバーの profiles.stamp_count を SUM() するだけ
- リアルタイムで家族合計が更新される

**4. 招待コードの設計:**
- families.id をそのまま招待コードとして使用
- UUIDをTEXT化した文字列（36文字）
- 将来的にQRコード化も容易

### ファイル一覧

**データベース:**
- `supabase/009_add_family_support.sql`
- `supabase/009_fix_rls_policies.sql`

**API:**
- `app/api/users/me/route.ts`
- `app/api/users/setup-role/route.ts`
- `app/api/families/join/route.ts`
- `app/api/families/me/route.ts`
- `app/api/families/update/route.ts`
- `app/api/families/members/route.ts`

**UI:**
- `app/onboarding/page.tsx`
- `app/family/join/page.tsx`
- `app/family/manage/page.tsx`
- `app/settings/page.tsx`

**ドキュメント:**
- `Doc/22_Phase2_実装計画書.md`
- `Doc/23_データベーススキーマ現状.md`
- `Doc/90_実装履歴.md`（本ファイル）

### 将来の拡張案（Phase 3以降）

1. **QRコードでの家族参加**
   - 招待コードをQRコード化
   - カメラで読み取って自動参加

2. **家族招待メッセージ**
   - LINEメッセージで招待リンクを送信
   - 「○○さんから家族に招待されました」

3. **家族ランキング**
   - 家族単位でのスタンプランキング
   - 月間TOP10表示

4. **複数の親（共同管理）**
   - representative_user_id を配列化
   - 夫婦で共同管理

5. **家族イベント**
   - 家族全員が来院したらボーナススタンプ
   - 家族限定の特典

### セキュリティ考慮事項

- 招待コードは36文字のランダム文字列（推測困難）
- family_role チェックは全APIで実施
- 親のみが編集・削除権限を持つ
- メンバーは自分の情報のみ参照可能

---

## 2026-02-17: 仮想メンバー機能実装完了

### 概要
スマートフォンやLINEアカウントを持たない子供のために、親が代理で登録・管理できる「仮想メンバー機能」を実装。親のスマホから子供専用のスタンプ画面を開き、スロットゲームも楽しめる。

**実装期間**: 2026-02-17（Phase 2実装完了直後、同日追加実装）

### 設計思想

**シンプル設計原則:**
- 新しいテーブルは作らない（既存のprofilesテーブルを活用）
- アカウント切り替え機能は作らない（直接子供モードを開く）
- 既存のKidsHomeコンポーネントを再利用
- 家族スタンプは個人スタンプの単純な合計（新しい概念を作らない）

**技術的実装:**
- 仮想メンバーは `line_user_id = NULL` で識別
- 手動生成ID: `manual-child-${randomUUID()}`
- LocalStorageで子供モード表示中の子供IDを管理

### データベース設計

**既存テーブル活用:**
```sql
-- 通常のメンバー（LINEアカウントあり）
INSERT INTO profiles VALUES (
  'U5c70cd61...',              -- LINE User ID
  'U5c70cd61...',              -- 同じ
  'Mio',
  '123456',
  NULL,
  30,  -- 3個
  3,
  '2026-02-15',
  'family-001',
  'child',
  'kids',
  NOW(),
  NOW()
);

-- 仮想メンバー（LINEアカウントなし）
INSERT INTO profiles VALUES (
  'manual-child-001',          -- 手動生成ID
  NULL,                        -- line_user_id = NULL
  '横山太郎',
  '123460',
  NULL,
  10,  -- 1個
  4,
  '2026-02-10',
  'family-001',
  'child',
  'kids',
  NOW(),
  NOW()
);
```

**識別方法:**
- `line_user_id IS NULL` → 仮想メンバー
- `line_user_id IS NOT NULL` → 実メンバー

### API実装（4本）

**1. POST /api/families/members/add:**
- 親が仮想子供メンバーを追加
- リクエスト: `{ userId, childName, ticketNumber }`
- 手動IDを生成: `manual-child-${randomUUID()}`
- profilesテーブルにINSERT（line_user_id = NULL）
- 家族紐付け: `family_id`, `family_role = 'child'`
- 権限チェック: `family_role === 'parent'` のみ実行可能

**2. PATCH /api/families/members/[memberId]:**
- 仮想子供メンバーの情報を編集
- リクエスト: `{ userId, childName, ticketNumber }`
- 名前と診察券番号を更新
- 権限チェック: 親のみ、同じ家族のメンバーのみ

**3. DELETE /api/families/members/[memberId]:**
- 仮想子供メンバーを削除
- 仮想メンバー（line_user_id = NULL）: profilesから完全削除
- 実メンバー（line_user_id != NULL）: family_idをNULLに（紐付け解除のみ）
- 権限チェック: 親のみ、同じ家族のメンバーのみ

**4. GET /api/profiles/[profileId]:**
- プロフィールIDでプロフィール情報を取得
- 仮想メンバーにも対応
- 子供モード画面で使用

**5. GET /api/families/me（修正）:**
- メンバー一覧に `line_user_id` と `ticket_number` を追加
- 仮想メンバーの識別に必要

### UI実装（3コンポーネント + 1ページ + 1修正）

**1. components/AddChildDialog.tsx（新規）:**
- 子供追加ダイアログコンポーネント
- 入力項目:
  - 名前（必須）
  - 診察券番号（任意）
- バリデーション: 名前の空文字チェック
- onSave コールバックで親コンポーネントに通知

**2. app/family/manage/page.tsx（大幅拡張）:**
- 「子供を追加」ボタン追加（親専用）
- メンバーカードに3つのボタン追加（仮想メンバーのみ）:
  - **開くボタン**: 子供モード画面へ遷移（LocalStorageにIDを保存）
  - **編集ボタン**: インライン編集モード（名前・診察券番号）
  - **削除ボタン**: 確認ダイアログ付き削除
- 仮想メンバーに「仮想」バッジ表示（紫色）
- インライン編集機能:
  - 編集モード切替（editingMember ステート管理）
  - 保存/キャンセルボタン
  - DOMから直接値を取得（getElementById）

**3. app/child-mode/page.tsx（新規）:**
- 仮想メンバー専用の子供モード画面
- LocalStorageから `currentChildId` を取得
- GET /api/profiles/[profileId] でプロフィール取得
- KidsHomeコンポーネントに profileOverride prop で渡す
- 戻るボタン: LocalStorageクリア → /family/manage へ
- カラフルな背景（グラデーション）

**4. components/(kids)/KidsHome.tsx（大幅実装）:**
- プレースホルダーから完全実装へ
- `profileOverride?: Profile` prop を追加
- プロフィール取得ロジック:
  - profileOverride がある場合: それを使用（仮想メンバー）
  - ない場合: useLiff() で通常のLIFFユーザー情報を取得
- スタンプカード表示（10個のマス、星アイコン）
- 進捗バー（カラフルなグラデーション）
- 励ましメッセージ（スタンプ数に応じて変化）
- スロットゲームボタン（/slotへのリンク）
- カラフルなデザイン（kids-pink, kids-yellow, kids-blue, kids-purple）

**5. app/slot/page.tsx（既存・変更なし）:**
- 歯科テーマのスロットゲーム
- タップで停止、3つ揃いで当たり
- 仮想メンバーも通常メンバーも同じゲームを楽しめる

### ユーザーフロー

**親の操作（仮想メンバー追加）:**
1. 設定 → 家族管理 → [+ 子供を追加]
2. ダイアログで名前と診察券番号を入力
3. [保存] → profilesに仮想メンバー追加
4. メンバー一覧に「仮想」バッジ付きで表示

**親の操作（子供モード開く）:**
1. 家族管理画面で仮想メンバーの [開く] ボタンをタップ
2. LocalStorageに currentChildId を保存
3. /child-mode へ遷移
4. 子供用のカラフル画面表示（ハブラーシカ、スタンプカード）
5. スロットゲームで遊べる
6. [かぞくかんりにもどる] で戻る

**親の操作（情報編集）:**
1. 家族管理画面で仮想メンバーの [編集] ボタンをタップ
2. インライン編集モードに切り替わり
3. 名前・診察券番号を修正
4. [保存] で PATCH /api/families/members/[memberId]

**親の操作（削除）:**
1. 家族管理画面で仮想メンバーの [削除] ボタンをタップ
2. 確認ダイアログ表示
3. [OK] で DELETE /api/families/members/[memberId]
4. profilesから完全削除

### 技術的な実装詳細

**LocalStorage利用:**
```typescript
// 子供モード開く時
localStorage.setItem('currentChildId', memberId);
router.push('/child-mode');

// 子供モード画面
const childId = localStorage.getItem('currentChildId');

// 戻る時
localStorage.removeItem('currentChildId');
router.push('/family/manage');
```

**KidsHomeのprofileOverride:**
```typescript
interface KidsHomeProps {
  profileOverride?: Profile; // 仮想メンバー用
}

export default function KidsHome({ profileOverride }: KidsHomeProps) {
  useEffect(() => {
    if (profileOverride) {
      // 仮想メンバー
      setDisplayName(profileOverride.display_name);
      setStampCount(profileOverride.stamp_count);
      return;
    }

    // 通常のLIFFユーザー
    if (liffProfile?.userId) {
      // Supabaseから取得
    }
  }, [profileOverride, liffProfile]);
}
```

**インライン編集の実装:**
```typescript
// 編集モード
const isEditingThis = editingMember?.id === member.id;

{isEditingThis ? (
  <div>
    <input id={`edit-name-${member.id}`} defaultValue={member.display_name} />
    <input id={`edit-ticket-${member.id}`} defaultValue={member.ticket_number || ''} />
    <button onClick={() => {
      const nameInput = document.getElementById(`edit-name-${member.id}`) as HTMLInputElement;
      const ticketInput = document.getElementById(`edit-ticket-${member.id}`) as HTMLInputElement;
      handleEditMember(member.id, nameInput.value, ticketInput.value);
    }}>保存</button>
  </div>
) : (
  // 通常表示
)}
```

### ファイル一覧

**API（新規）:**
- `app/api/families/members/add/route.ts`
- `app/api/families/members/[memberId]/route.ts`（PATCH + DELETE）
- `app/api/profiles/[profileId]/route.ts`

**API（修正）:**
- `app/api/families/me/route.ts`（メンバー一覧に line_user_id, ticket_number を追加）

**UI（新規）:**
- `components/AddChildDialog.tsx`
- `app/child-mode/page.tsx`

**UI（大幅修正）:**
- `app/family/manage/page.tsx`（子供追加・編集・削除・開くボタン追加）
- `components/(kids)/KidsHome.tsx`（プレースホルダーから完全実装へ）

**ドキュメント:**
- `Doc/25_仮想メンバー機能仕様書.md`（設計書、前の会話で作成）
- `Doc/90_実装履歴.md`（本ファイル）

### スタンプ付与について

**現状:**
- 仮想メンバーのスタンプ付与は未実装
- 親が子供モードを開いてもQRスキャンはできない

**将来の実装（Phase 3以降）:**
1. **子供モードでQRスキャン:**
   - KidsHomeにQRスキャンボタン追加
   - スキャン時にprofileOverride.idを使用してスタンプ付与

2. **親の管理画面から手動付与:**
   - 家族管理画面でスタッフピン認証
   - 仮想メンバーのスタンプ数を直接編集

3. **スタッフ側管理画面:**
   - Phase 7の管理ダッシュボードで一括管理
   - 診察券番号で検索して付与

### 動作確認項目

**追加機能:**
- [x] 親が「子供を追加」ボタンで仮想メンバーを追加できる
- [x] 名前と診察券番号を入力できる
- [x] メンバー一覧に「仮想」バッジ付きで表示される
- [x] 「開く」ボタンで子供モード画面が開く
- [x] 子供モード画面でスタンプカードが表示される
- [x] 「編集」ボタンで名前・診察券番号を修正できる
- [x] 「削除」ボタンで仮想メンバーを削除できる
- [x] LocalStorageが正しく管理される
- [x] スロットゲームへのリンクが機能する

**既存機能との整合性:**
- [x] 家族スタンプ合計に仮想メンバーのスタンプが含まれる
- [x] 実メンバーの削除は紐付け解除のみ（完全削除されない）
- [x] 仮想メンバーの削除は完全削除される
- [x] 親の権限チェックが正しく機能する

### 将来の拡張案

1. **スタンプ付与機能:**
   - 子供モード画面でQRスキャン機能
   - 親の管理画面から手動付与

2. **プロフィール画像:**
   - 仮想メンバーにアバター設定
   - 動物や乗り物のアイコンから選択

3. **子供専用ゲーム拡充:**
   - スロット以外のミニゲーム追加
   - スタンプ数に応じて解放

4. **子供専用メッセージ:**
   - 「次回は○月○日だよ！」
   - 全ひらがな表示

5. **複数の仮想メンバー管理:**
   - 一覧表示の最適化
   - ソート・フィルター機能

### セキュリティ考慮事項

- 仮想メンバーの操作は親（family_role = 'parent'）のみ可能
- 同じ家族のメンバーのみ操作可能（family_id チェック）
- 手動生成IDは推測困難（UUID使用）
- LocalStorageは同一ブラウザのみで有効（他人のアクセス不可）

### デプロイ注意事項

- データベーススキーマ変更なし（既存のprofilesテーブルのみ使用）
- 新規APIエンドポイント4本追加
- 環境変数変更なし
- Vercelへのデプロイは通常通り

---

## 2026-02-22: スマホなし子供機能の改善とバグ修正

### 概要
スマホを持たない子供（代理管理メンバー）の名前管理を`real_name`フィールドに統一し、キッズモード設定画面でlocalStorageキー名の不一致によるバグを修正。

**実装期間**: 2026-02-22

### 問題の発見

**問題1: データ項目の設計判断**
- ユーザーからの指摘: 「スマホなしの子供を追加するときは、display_nameではなくreal_nameに保存する必要がある」
- 理由: 
  - `display_name`: LINEの表示名または検索用（実際のLINEメンバー用）
  - `real_name`: 医療記録用の本名（代理管理メンバー用）
- スマホなし子供は医療機関での記録のため、実名管理が必須

**問題2: localStorageのキー名不一致**
- 症状: 子供モード設定画面で「子供IDが見つかりません」エラー
- 原因:
  - ViewModeContext: `selectedChildId` というキーで保存
  - キッズモード設定画面: `currentChildId` というキーで取得（❌ 間違い）
- 影響: 親が子供画面に切り替えても、設定画面が正しく動作しない

### データモデル設計の修正

**real_nameフィールドの活用:**
```typescript
// スマホあり（LINEメンバー）
{
  id: "U5c70cd61...",
  line_user_id: "U5c70cd61...",  // LINEアカウント
  display_name: "横山光紀",      // LINEの表示名
  real_name: null,                // 使用しない
}

// スマホなし（代理管理メンバー）
{
  id: "manual-child-xxx",
  line_user_id: null,             // LINEアカウントなし
  display_name: "すまほなしこ",   // 検索用・互換性用
  real_name: "すまほなしこ",     // 本名（実際の名前）★ こちらを使用
}
```

**表示ロジックの統一:**
- スマホなし子供: `real_name || "登録なし"` を表示
- `display_name`の有無に関わらず、`real_name`がなければ「登録なし」
- スマホあり子供: `display_name` を表示（従来通り）

### 修正したファイル

**1. app/api/families/members/add/route.ts**
- 仮想メンバー追加時に`real_name`にも保存
```typescript
.insert({
  id: virtualChildId,
  line_user_id: null,
  display_name: childName,  // 検索用・互換性用
  real_name: childName,     // 本名（実際の名前）★ 追加
  ticket_number: ticketNumber || null,
  // ...
})
```

**2. app/api/families/members/[memberId]/route.ts**
- 仮想メンバー編集時に両方更新
```typescript
if (childName !== undefined) {
  updateData.display_name = childName;  // 検索用・互換性用
  updateData.real_name = childName;     // 本名（実際の名前）★ 追加
}
```

**3. app/api/families/me/route.ts**
- メンバー一覧取得時に`real_name`も含める
```typescript
.select("id, display_name, real_name, family_role, stamp_count, visit_count, line_user_id, ticket_number")
```

**4. app/child-mode/settings/page.tsx（重要な修正）**
- **問題**: localStorageから`currentChildId`を取得していた
- **修正**: ViewModeContextから`selectedChildId`を直接取得
```typescript
// 修正前: localStorageを直接使用
const [childId, setChildId] = useState<string | null>(null);
const id = localStorage.getItem('currentChildId'); // ❌ 間違ったキー名

// 修正後: ViewModeContextから取得
const { selectedChildId, setSelectedChildId, setViewMode } = useViewMode();
if (!selectedChildId) {
  throw new Error('子供IDが見つかりません');
}
```

- `real_name`を優先して表示・保存
```typescript
// 取得時
setDisplayName(data.profile.real_name || data.profile.display_name || '');

// 保存時
.update({
  display_name: displayName.trim(),  // 検索用・互換性用
  real_name: displayName.trim(),     // 本名（実際の名前）
  ticket_number: ticketNumber.trim() || null,
})
```

**5. app/child-mode/page.tsx**
- localStorageキー名を統一（将来の互換性のため）
```typescript
// 修正前
const childId = localStorage.getItem('currentChildId');

// 修正後
const childId = localStorage.getItem('selectedChildId');
```

**6. components/(kids)/KidsHome.tsx**
- `real_name`を優先して表示
```typescript
// Supabaseクエリに real_name 追加
.select("stamp_count, display_name, real_name, ticket_number, next_visit_date, next_memo, family_id")

// 表示ロジック修正
setDisplayName(data.real_name || "登録なし");  // display_nameは使わない
```

**7. app/family/manage/page.tsx**
- FamilyMemberインターフェースに`real_name`追加
- 表示ロジックを仮想メンバーかどうかで分岐
```typescript
interface FamilyMember {
  id: string;
  display_name: string;
  real_name: string | null;  // 追加
  // ...
}

// 表示部分
{isVirtualChild ? (member.real_name || "登録なし") : member.display_name}
```

**8. app/settings/page.tsx**
- ProxyChildインターフェースに`real_name`追加
- 子供画面一覧で`real_name`を優先表示
```typescript
interface ProxyChild {
  id: string;
  display_name: string;
  real_name: string | null;  // 追加
  stamp_count: number;
}

// 表示部分
子供の画面：{child.real_name || child.display_name || "登録なし"}
```

**9. components/layout/AppLayout.tsx**
- TypeScript型エラー修正（kidsHrefプロパティ）
```typescript
const TABS = [
  { href: "/", label: "診察券", icon: CreditCard, kidsHref: undefined },
  // ... 他のタブも同様
  { href: "/settings", label: "設定", icon: Settings, kidsHref: "/child-mode/settings" },
] as const;
```

### キッズモード設定画面に「親のモードに戻る」ボタン追加

**背景:**
- 親が誤って自分のアカウントでキッズモードに入った場合、戻る手段がない
- 発生頻度は低いが、完全に閉じ込められてしまう

**実装:**
```typescript
// ViewModeContextを使用
const { selectedChildId, setSelectedChildId, setViewMode } = useViewMode();

// 親のモードに戻る関数
const handleBackToParentMode = async () => {
  setSelectedChildId(null);      // selectedChildIdをクリア
  await setViewMode('adult');    // 大人用モードに切り替え
  router.push('/');              // ホーム画面にリダイレクト
};

// UIボタン追加
<button onClick={handleBackToParentMode}>
  <LogOut size={20} />
  <span>おやの モード に もどる</span>
</button>
<p className="text-xs text-white/80 text-center mt-2">
  ※ おやが まちがえて きっずもーど に なった ときに つかってね
</p>
```

### データフロー（修正後）

**子供画面への遷移:**
```
親が設定画面で「子供の画面：すまほなしこ」をクリック
  ↓
ViewModeContext.setSelectedChildId(childId)
  ↓
localStorage.setItem('selectedChildId', childId)  ★ キー名統一
  ↓
ViewModeContext.setViewMode('kids')
  ↓
router.push('/') → KidsHomeが表示
  ↓
設定ボタンをクリック → /child-mode/settings
  ↓
ViewModeContextから selectedChildId を取得 ★ 修正後は正しく取得できる
  ↓
/api/profiles/${selectedChildId} でプロフィール取得
  ↓
real_name を優先的に表示 ★ 本名が表示される
```

### 表示ロジックの統一ルール

**スマホなし子供（代理管理メンバー）:**
1. 保存: `real_name` と `display_name` の両方に保存
2. 取得: `real_name` を最優先
3. 表示: `real_name || "登録なし"`（display_nameは無視）

**スマホあり子供（実メンバー）:**
1. 保存: `display_name`のみ（LINEから自動取得）
2. 取得: `display_name`
3. 表示: `display_name`

### UI/UXの改善

**「スマホなしの子供を追加」の明確化:**
- ボタンテキスト: 「👶 スマホなしの子供を追加」
- ダイアログタイトル: 「👶 スマホなしの子供を追加」
- 説明文追加: 「スマホやLINEアカウントを持っていない小さなお子様を登録します。親が代わりに管理できます。」

**招待コードとの区別:**
- 招待コードセクション: 「📱 お子様のスマホから参加」
- 追加ボタン: 「👶 スマホなしの子供を追加」
- アイコンで視覚的に区別

### トラブルシューティング

**問題: キッズモード設定画面で「子供IDが見つかりません」**
- 原因: localStorageのキー名不一致（`currentChildId` vs `selectedChildId`）
- 解決: ViewModeContextから直接`selectedChildId`を取得

**問題: 子供の名前が正しく表示されない**
- 原因: `display_name`を使用していた
- 解決: スマホなし子供は`real_name`を優先

**問題: 名前編集しても反映されない**
- 原因: `real_name`を更新していなかった
- 解決: 保存時に両方（`display_name`と`real_name`）を更新

### テスト確認項目

**スマホなし子供の追加:**
- [x] 「👶 スマホなしの子供を追加」ボタンが表示される
- [x] 名前と診察券番号を入力できる
- [x] 保存後、メンバー一覧に表示される
- [x] `real_name`と`display_name`の両方に保存される

**子供画面への切り替え:**
- [x] 設定画面で「子供の画面」ボタンをクリックできる
- [x] キッズホーム画面が表示される
- [x] `real_name`が正しく表示される（`real_name`がない場合は「登録なし」）

**キッズモード設定画面:**
- [x] 設定ボタンをタップして設定画面が開く
- [x] 「子供IDが見つかりません」エラーが出ない ★ 修正後
- [x] 名前と診察券番号を編集できる
- [x] 保存後、即座に反映される
- [x] 「おやの モード に もどる」ボタンで親画面に戻れる

**データ整合性:**
- [x] 家族管理画面で`real_name`が表示される
- [x] キッズホーム画面で`real_name`が表示される
- [x] キッズモード設定画面で`real_name`が表示・編集される
- [x] すべての画面で表示ロジックが統一されている

### ビルド確認

- ✅ TypeScript型チェック成功（`npx tsc --noEmit`）
- ✅ Production build成功（`npm run build`）
- データベーススキーマ変更なし
- 環境変数変更なし

### セキュリティ

- localStorageはブラウザ単位で管理（他人のアクセス不可）
- ViewModeContextで一元管理（データの一貫性保証）
- APIレイヤーで親の権限チェック（変更なし）

### 今後の注意事項

**localStorageキーの統一:**
- 必ず`selectedChildId`を使用
- `currentChildId`は使わない（削除済み）

**名前フィールドの使い分け:**
- スマホなし子供: `real_name`を使用
- スマホあり子供: `display_name`を使用
- 表示時は必ずロジックで分岐

**ViewModeContextの活用:**
- localStorageを直接操作しない
- ViewModeContextのAPIを使用して状態管理

### ドキュメント更新

- `Doc/90_実装履歴.md`: 本セクションを追加
- `Doc/70_子供画面切替機能仕様.md`: 技術仕様を更新予定


---

## 2026-02-22: QRコードスキャン機能実装

### 概要
LIFFアプリ内でQRコードをスキャンし、スタンプを付与する機能を実装。Doc/81_QRコード表示_LIFFアプリ開発者へ.mdの仕様に基づき、premium（10個）とregular（5個）の2種類のQRコードペイロードに対応。

**実装期間**: 2026-02-22

### 実装内容

#### 1. バックエンドAPI

**`app/api/stamps/scan/route.ts`** (新規作成)
- POST `/api/stamps/scan` エンドポイント
- QRコードペイロード（type, stamps）を受け取りスタンプ付与
- リクエスト形式:
```json
{
  "userId": "U5c70cd61...",
  "type": "premium" | "regular",
  "stamps": 10 | 5,
  "qrCodeId": "premium_2026-02-22"
}
```

**機能:**
- ユーザー存在チェック（profiles テーブル）
- 重複チェック：同日同QRコードIDでの登録を防止
- stamp_history にレコード挿入（stamp_method = 'qr_scan'）
- DBトリガーで profiles.stamp_count が自動更新

**エラーハンドリング:**
- 400: 必須パラメータ不足、無効なタイプ/スタンプ数
- 404: ユーザーが見つからない
- 409: 重複スキャン（同日同QRコードID）
- 500: サーバーエラー

#### 2. フロントエンド

**`app/scan/page.tsx`** (新規作成)
- QRコードスキャン専用ページ
- LIFF SDK `scanCodeV2()` を使用してQRコードをスキャン
- QRペイロードをJSONパースして検証
- `/api/stamps/scan` APIを呼び出し

**UI/UX:**
- グラデーション背景（青→白→緑）
- 大きなスキャンボタン（カメラアイコン付き）
- 成功表示：緑色カード + 獲得スタンプ数 + 合計スタンプ数
- エラー表示：赤色カード + エラーメッセージ
- 注意事項：黄色カード（1日1回のみ、設置場所案内）

**開発者モード（開発環境のみ）:**
- 手動入力フォーム
- プリセットボタン（premium 10個 / regular 5個）
- カメラなしでテスト可能

**`types/liff.d.ts`** (新規作成)
- LIFF SDK `scanCodeV2()` メソッドの型定義を追加

```typescript
interface Window {
  liff: {
    scanCodeV2?: () => Promise<{
      value: string | null;
    }>;
  };
}
```

### QRコードペイロード仕様

Doc/24の仕様に準拠：

**優良患者様用（10個）:**
```json
{"type":"premium","stamps":10}
```

**通常患者様用（5個）:**
```json
{"type":"regular","stamps":5}
```

### データフロー

```
ユーザーが院内QRコードをスキャン
  ↓
LIFF: window.liff.scanCodeV2() → QRコード値取得
  ↓
JSONパース & 検証
  ↓
POST /api/stamps/scan
  ↓
サーバー側処理:
  1. ユーザー存在チェック
  2. 重複チェック（同日同QRコードID）
  3. stamp_history INSERT
  4. profiles.stamp_count 自動更新（DBトリガー）
  ↓
レスポンス: { success: true, stampCount, stampsAdded }
  ↓
UI更新: 成功メッセージ + 診察券リンク
```

### 重複防止機能

**仕様:**
- 同一ユーザー + 同一QRコードID + 同日の組み合わせをチェック
- `qrCodeId` は `${type}_${date}` 形式（例: `premium_2026-02-22`）
- 日付が変わると別のスキャンとして認識

**実装:**
```typescript
const today = new Date().toISOString().split("T")[0];
const existing = await supabase
  .from("stamp_history")
  .select("id")
  .eq("user_id", userId)
  .eq("qr_code_id", qrCodeId)
  .gte("visit_date", `${today}T00:00:00`)
  .lt("visit_date", `${today}T23:59:59`)
  .maybeSingle();

if (existing) {
  return 409 Conflict;
}
```

### セキュリティ

- LIFF SDK経由でLINEユーザーID取得
- サーバー側で profiles テーブル存在チェック
- 重複防止（1日1回制限）
- JSON検証（type, pointsの妥当性チェック）

### テスト手順

**本番環境（LIFFブラウザ）:**
1. LINEアプリでミニアプリを開く
2. `/scan` ページに移動
3. 「QRコードをスキャン」ボタンをタップ
4. カメラ起動を確認
5. テスト用QRコードをスキャン
6. 成功メッセージ確認
7. 診察券ページでスタンプ数増加を確認
8. 同じQRコードを再スキャン → 重複エラー確認

**開発環境（手動入力）:**
1. `npm run dev` で起動
2. `/scan` ページに移動
3. 開発者モードの手動入力セクションが表示されることを確認
4. プリセットボタンで `{"type":"premium","points":10}` を入力
5. 送信 → 成功メッセージ確認

### ビルド確認

- ✅ TypeScript型チェック成功（`npx tsc --noEmit`）
- ✅ 環境変数変更なし
- ✅ データベーススキーマ変更なし（既存の stamp_history テーブルを使用）

### 今後の拡張案

**本番用QRコード:**
- 1回限り有効なトークン付きQRコード
- 有効期限チェック
- ペイロード拡張例:
```json
{
  "type": "premium",
  "stamps": 10,
  "token": "abc123xyz789",
  "expires_at": "2026-02-22T23:59:59Z"
}
```

**管理ダッシュボード機能:**
- 日付ごとのQRコード生成機能
- PDF出力・印刷機能
- A4サイズテンプレート

**ユーザー向け機能:**
- スキャン履歴表示
- 獲得スタンプ数の統計

### ドキュメント

- `Doc/82_QRコードスキャン機能_実装完了.md`: 詳細な実装ドキュメント
- `Doc/24_QRコード表示_LIFFアプリ開発者へ.md`: 元の仕様書

---

## 2026-02-23: QRコードスキャン機能のバグ修正（重要）

### 概要
QRコードスキャン機能で「通常患者様用（5個）」をスキャンしても常に10個付与されていたバグを修正。ドキュメント通り `stamps` フィールドを使用するように全面的に修正。

**実装期間**: 2026-02-23

### 発生した問題

**症状:**
- QRコード「通常患者様用（5個）」をスキャンしても、**常に10個**付与されていた

**根本原因:**
1. **ドキュメント（Doc/24）を無視した実装ミス**
   - ドキュメントに「`stamps` を使用」と明記されていたが、実装では `points` を使用
2. **複数のAPIエンドポイントが存在**
   - `/api/stamps` (古い汎用スタンプAPI) - **常に10個固定で付与**
   - `/api/stamps/scan` (新しいQRスキャン専用API) - 本来こちらを使うべき
3. **ブラウザキャッシュ**
   - フロントエンドコードが古いままキャッシュされ、修正後も `/api/stamps` を呼び出していた

### 修正内容

#### 1. app/api/stamps/route.ts（重要な修正）

**問題箇所:**
```typescript
const stampAmount = STAMP_AMOUNTS.REGULAR_VISIT; // 通常来院: +10個（固定値）
```

**修正後:**
```typescript
// QRコードからスタンプ数を解析
let stampAmount = STAMP_AMOUNTS.REGULAR_VISIT; // デフォルト: +10個
try {
  const qrPayload = JSON.parse(qrCodeId);
  if (qrPayload.stamps && typeof qrPayload.stamps === 'number') {
    stampAmount = qrPayload.stamps; // QRコードの stamps 値を使用
    console.log(`📱 [Stamps API] QRコードから読み取り: ${stampAmount}個`);
  }
} catch {
  // JSONパースエラー = 通常のQRコードID、デフォルト値を使用
}
```

**理由:**
- ブラウザキャッシュで古いフロントエンドコードが動作し、`/api/stamps` を呼び出していた
- QRコードJSONをパースしてスタンプ数を動的に読み取るように修正
- 後方互換性を保ちながら正しい動作を実現

#### 2. app/scan/page.tsx（全面修正）

**変更内容:**
- `points` → `stamps` に全て変更
- QRペイロード型定義を修正
- API呼び出しパラメータを修正

```typescript
interface QRPayload {
  type: 'premium' | 'regular';
  stamps: number;  // pointsではなくstamps
}

// APIリクエスト
body: JSON.stringify({
  userId: profile!.userId,
  type: payload.type,
  stamps: payload.stamps,  // stampsに統一
  qrCodeId: `${payload.type}_${new Date().toISOString().split('T')[0]}`,
})
```

#### 3. app/api/stamps/scan/route.ts（全面修正）

**変更内容:**
- すべての `points` → `stamps` に変更
- リクエスト型定義を修正
- レスポンス型定義を修正

```typescript
interface QRScanRequest {
  userId: string;
  type: "premium" | "regular";
  stamps: number;  // 付与スタンプ個数 (必須)
  qrCodeId?: string;
}

// Validation
if (!userId || !type || stamps === undefined) {
  return NextResponse.json({
    success: false,
    message: "必須パラメータが不足しています",
    error: "Missing required fields: userId, type, stamps",
  }, { status: 400 });
}
```

#### 4. types/stamp.ts（修正）

**追加内容:**
- `amount` フィールドをStampHistoryRecord型に追加

```typescript
export interface StampHistoryRecord {
  // ... 既存フィールド
  amount: number | null; // QRスキャンで獲得したスタンプ個数（通常5、優良10）
}
```

#### 5. components/(adult)/AdultStampPage.tsx（修正）

**変更内容:**
- QRスキャン成功メッセージに獲得個数を表示

```typescript
setMessage(`✅ QRコード ${response.stampsAdded}個獲得`);
```

#### 6. lib/supabase.ts（セキュリティ強化）

**追加内容:**
- サービスロールクライアント `getSupabaseAdmin()` を追加
- RLS（Row Level Security）をバイパスして管理操作が可能に

```typescript
export const getSupabaseAdmin = () => {
  const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY ?? "";

  if (!supabaseServiceRoleKey) {
    throw new Error("SUPABASE_SERVICE_ROLE_KEY is not set");
  }

  return createClient(supabaseUrl, supabaseServiceRoleKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  });
};
```

#### 7. app/api/stamps/scan/delete-today/route.ts（新規作成）

**目的:**
- テスト用：本日のQRスキャン履歴を削除する機能
- スタッフが3タップで秘密操作として使用

**実装:**
```typescript
export async function POST(request: NextRequest): Promise<NextResponse<DeleteTodayQRResponse>> {
  const supabaseAdmin = getSupabaseAdmin(); // RLSバイパス

  // 本日のQRスキャンを取得
  const { data: todayScans } = await supabaseAdmin
    .from("stamp_history")
    .select("*")
    .eq("user_id", userId)
    .eq("stamp_method", "qr_scan")
    .gte("visit_date", startOfDay)
    .lte("visit_date", endOfDay);

  // 削除
  await supabaseAdmin
    .from("stamp_history")
    .delete()
    .in("id", idsToDelete);

  // スタンプ数を再計算
  const newStampCount = allHistory?.reduce((sum, record) => sum + (record.amount || 0), 0) || 0;

  await supabaseAdmin
    .from("profiles")
    .update({ stamp_count: newStampCount })
    .eq("id", userId);
}
```

#### 8. components/shared/StaffPinModal.tsx（機能追加）

**追加内容:**
- 「本日のQRスキャンを削除」ボタンを追加
- テスト時に重複エラーを回避するため

```typescript
const handleDeleteTodayQR = async () => {
  const response = await fetch("/api/stamps/scan/delete-today", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ userId }),
  });

  const result = await response.json();
  if (result.success) {
    alert(result.message);
    window.location.reload();
  }
};

// UIボタン
<button onClick={handleDeleteTodayQR}>
  🗑️ 本日のQRスキャンを削除
</button>
```

#### 9. components/(adult)/AdultHome.tsx（修正）

**変更内容:**
- StaffPinModalに `userId` プロパティを渡す

```typescript
<StaffPinModal
  isOpen={showStaffModal}
  onClose={() => setShowStaffModal(false)}
  currentStampCount={stampCount}
  onSubmit={handleStaffSubmit}
  isLoading={isStaffLoading}
  userId={profile?.userId}  // 追加
/>
```

#### 10. .env.local（追加）

**追加内容:**
```
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key_here
```

**注意:** 実際のキーは `.env.local` ファイルを参照してください。セキュリティ上の理由から、ここには記載しません。

### ドキュメント更新

**Doc/82_QRコードスキャン機能_実装完了.md:**
- 「⚠️ 重要：実装時の問題と対策」セクションを追加
- 根本原因、修正内容、今後の対策を詳細に記載
- すべての `points` を `stamps` に統一

**Doc/90_実装履歴.md（本ファイル）:**
- 本セクションを追加

**Doc/100_主な機能一覧（クライアント説明用）.md:**
- QRコードスキャン機能の説明を追加予定

### 今後の対策

**必須ルール:**
1. **Doc/24の仕様を厳守**
   - `stamps` フィールドを使用（`points` ではない）
2. **正しいAPIエンドポイントを使用**
   - QRスキャン: `/api/stamps/scan`
   - 汎用スタンプ: `/api/stamps`（QRスキャンでは使わない）
3. **キャッシュクリア手順を文書化**
   - 開発サーバー再起動
   - LINEアプリ再起動
   - ブラウザキャッシュクリア
4. **テスト手順の確立**
   - 通常患者用（5個）
   - 優良患者用（10個）
   - 両方をテストして確認

### 動作確認

**通常患者用（5個）:**
- ✅ QRコードをスキャン → 5個付与される
- ✅ 「✅ QRコード 5個獲得」と表示される
- ✅ スタンプ数が正しく増加

**優良患者用（10個）:**
- ✅ QRコードをスキャン → 10個付与される
- ✅ 「✅ QRコード 10個獲得」と表示される
- ✅ スタンプ数が正しく増加

**削除機能（テスト用）:**
- ✅ スタッフモーダルから「本日のQRスキャンを削除」ボタンが機能
- ✅ 削除後、スタンプ数が正しく減少
- ✅ 再度スキャン可能

### トラブルシューティング履歴

**問題1: RLS削除エラー**
- 症状: 削除APIが成功を返すがデータが削除されない
- 原因: 匿名キーではRLSポリシーで削除がブロックされる
- 解決: `getSupabaseAdmin()` でサービスロールキーを使用

**問題2: タイムゾーン問題**
- 症状: 削除クエリで今日のレコードが取得できない
- 原因: `T00:00:00` だけだとタイムゾーンが不明確
- 解決: `.000Z` を付けてUTCを明示

**問題3: ポート競合**
- 症状: ポート4000で起動失敗
- 原因: 既存のnodeプロセスが残っている
- 解決: PowerShellで該当プロセスを停止

### ビルド確認

- ✅ TypeScript型チェック成功（`npx tsc--noEmit`）
- ✅ 環境変数追加: `SUPABASE_SERVICE_ROLE_KEY`
- ✅ データベーススキーマ変更なし

---

## 2026-02-27: スタンプ履歴表示改善 & アンケート報酬バグ修正

### 概要
前セッションで実装したアンケート機能に2つの重大なバグを修正し、スタンプ履歴表示を全面的に改善。

**実装期間**: 2026-02-27

### 問題の発見

**バグ1: アンケート報酬で来院回数が増加（重大）**
- 症状: アンケートに回答すると、来院回数が+1され、10個ではなく3個のスタンプしか付与されない
- 根本原因: `update_profile_stamp_count()` トリガー関数が `last_visit_date` を全レコード対象で更新していた
- 影響: アンケート報酬（stamp_method = 'survey_reward'）も「来院」としてカウントされていた

**バグ2: トリガー関数でvisit_count更新が抜けていた**
- 症状: visit_count が正しく更新されない
- 根本原因: 018マイグレーションで visit_count の更新処理を含めていなかった
- 影響: 家族合計の訪問回数などが正しく計算されない

**UI問題: すべてのスタンプ履歴が「XX回目の来院」表示**
- 症状: QRスキャン、アンケート報酬、スタッフ操作すべてが「来院」として表示
- ユーザーの要望: 「スタンプ（今回の獲得数＋合計獲得数）がベースで、その理由が・来院（QRコード）・スタッフ操作・アンケート報酬なのかというのがサブ的に表示されるようにしたい」

### データベース修正

**supabase/018_fix_survey_reward_trigger.sql（新規作成 + ユーザー修正）**

初期実装:
```sql
CREATE OR REPLACE FUNCTION update_profile_stamp_count()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE profiles
  SET
    stamp_count = (
      SELECT COALESCE(MAX(stamp_number), 0)
      FROM stamp_history
      WHERE user_id = NEW.user_id
    ),
    last_visit_date = (
      SELECT MAX(visit_date)
      FROM stamp_history
      WHERE user_id = NEW.user_id
        AND stamp_method != 'survey_reward'  -- アンケート報酬は来院扱いにしない
    ),
    updated_at = NOW()
  WHERE id = NEW.user_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

ユーザーによる修正（visit_count追加）:
```sql
CREATE OR REPLACE FUNCTION update_profile_stamp_count()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE profiles
  SET
    stamp_count = (
      SELECT COALESCE(MAX(stamp_number), 0)
      FROM stamp_history
      WHERE user_id = NEW.user_id
    ),
    visit_count = (
      SELECT COUNT(*)
      FROM stamp_history
      WHERE user_id = NEW.user_id AND amount = 10
    ),
    last_visit_date = (
      SELECT MAX(visit_date)
      FROM stamp_history
      WHERE user_id = NEW.user_id
        AND stamp_method != 'survey_reward'
    ),
    updated_at = NOW()
  WHERE id = NEW.user_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

**重要な設計判断:**
- `visit_count`: amount = 10 のレコードのみカウント（アンケート報酬は amount = 30 なので自然に除外）
- `last_visit_date`: stamp_method != 'survey_reward' で明示的に除外
- `stamp_count`: すべてのレコードを含む（MAX(stamp_number)）

### ドキュメント修正

**Doc/03_機能仕様書.md: 33行目**
- 修正前: `stamp_method | TEXT | 登録方法（'qr_scan' or 'manual_admin'）`
- 修正後: `stamp_method | TEXT | 登録方法（'qr_scan' / 'manual_admin' / 'import' / 'survey_reward'）`

**Doc/05_Database_Schema.md: 184行目**
- 修正前: `取得方式 ('qr_scan', 'manual_admin', 'import')`
- 修正後: `取得方式 ('qr_scan', 'manual_admin', 'import', 'survey_reward')`

### 型定義の更新

**types/stamp.ts: 13行目**
```typescript
export interface StampHistoryRecord {
  // ...
  stamp_method: "qr_scan" | "manual_admin" | "import" | "survey_reward";  // 追加
  // ...
}
```

### ヘルパー関数の追加

**lib/stamps.ts（追加）**

```typescript
/**
 * スタンプ付与量の定数
 */
export const STAMP_AMOUNTS = {
  REGULAR_VISIT: 10,
  SLOT_MIN: 3,
  SLOT_MID: 5,
  SLOT_MAX: 8,
  SURVEY_REWARD: 30,  // 追加
} as const;

/**
 * スタンプ取得方法のラベルを取得
 */
export const getStampMethodLabel = (
  stampMethod: StampHistoryRecord["stamp_method"]
): string => {
  switch (stampMethod) {
    case "qr_scan":
      return "来院（QRコード）";
    case "manual_admin":
      return "スタッフ操作";
    case "import":
      return "データ移行";
    case "survey_reward":
      return "アンケート回答報酬";
    default:
      return "不明";
  }
};

/**
 * スタンプ取得方法に応じたアイコン名を取得（lucide-react）
 */
export const getStampMethodIcon = (
  stampMethod: StampHistoryRecord["stamp_method"]
): "QrCode" | "User" | "Package" | "FileText" => {
  switch (stampMethod) {
    case "qr_scan":
      return "QrCode";
    case "manual_admin":
      return "User";
    case "import":
      return "Package";
    case "survey_reward":
      return "FileText";
    default:
      return "QrCode";
  }
};
```

### UI実装の変更

**components/(adult)/AdultStampPage.tsx（大幅修正）**

**修正前:**
```typescript
{stampHistory.map((record, index) => {
  const visitNumber = stampHistory.length - index; // 訪問回数（最新が1番目）
  return (
    <li key={record.id}>
      <CheckCircle2 className="..." />
      <p>{visitNumber}回目の来院</p>  // ← すべて「来院」表示
      <p>{formatStampDate(record.visit_date)} • スタンプ {recordStamps}個</p>
    </li>
  );
})}
```

**修正後:**
```typescript
{stampHistory.map((record) => {
  const acquiredAmount = record.amount || 0;
  const methodLabel = getStampMethodLabel(record.stamp_method);
  const iconName = getStampMethodIcon(record.stamp_method);

  // アイコンコンポーネントの選択
  const IconComponent =
    iconName === "QrCode" ? QrCode :
    iconName === "User" ? User :
    iconName === "Package" ? Package :
    FileText;

  // スタンプ取得方法に応じた背景色
  const bgColor =
    record.stamp_method === "qr_scan" ? "bg-primary/10" :
    record.stamp_method === "survey_reward" ? "bg-green-500/10" :
    record.stamp_method === "manual_admin" ? "bg-amber-500/10" :
    "bg-gray-400/10";

  // アイコン色
  const iconColor =
    record.stamp_method === "qr_scan" ? "text-primary" :
    record.stamp_method === "survey_reward" ? "text-green-600" :
    record.stamp_method === "manual_admin" ? "text-amber-600" :
    "text-gray-500";

  return (
    <li key={record.id}>
      <div className={`... ${bgColor}`}>
        <IconComponent className={`... ${iconColor}`} />
      </div>
      <div>
        {/* メインライン: +XX個獲得（合計 YY個） */}
        <p className="text-sm font-bold text-gray-900">
          +{acquiredAmount}個獲得（合計 {recordStamps}個）
        </p>
        {/* サブライン1: 取得方法 */}
        <p className="text-xs font-medium text-gray-600 mt-0.5">
          {methodLabel}
        </p>
        {/* サブライン2: 日時 */}
        <p className="text-xs text-gray-500 mt-0.5">
          {formatStampDate(record.visit_date)}
        </p>
      </div>
    </li>
  );
})}
```

**セクション名変更:**
- 「来院履歴」→「スタンプ獲得履歴」

**アイコンインポート追加:**
```typescript
import { Trophy, QrCode, User, Package, FileText } from "lucide-react";
```

### 表示例（実装後）

```
[🎯] +10個獲得（合計 53個）
     来院（QRコード）
     2026年2月26日 22:41

[📝] +30個獲得（合計 50個）
     アンケート回答報酬
     2026年2月26日 22:12

[👤] +5個獲得（合計 45個）
     スタッフ操作
     2026年2月25日 15:30

[📦] +10個獲得（合計 10個）
     データ移行
     2026年2月20日 00:00
```

**色分け:**
- 来院（QRコード）: 青系（primary）
- アンケート報酬: 緑系
- スタッフ操作: オレンジ系
- データ移行: グレー系

### 仕様書の作成

**Doc/90_スタンプ履歴表示改善仕様.md（新規作成）**

包括的な設計ドキュメントを作成:
1. 現状の問題点
2. 新しい表示方針
3. データ構造の確認
4. 画面表示設計
5. 実装方針
6. 具体的な実装例
7. 表示例（実際のデータ）
8. テストケース
9. 実装チェックリスト
10. 実装完了状況（2026-02-27追記）

### ドキュメント更新（追加）

**Doc/100_主な機能一覧（クライアント説明用）.md**

**セクション追加:**
- 「5. アンケート機能」セクションを新規追加
- 主な機能、質問項目、データベース構造、運用ポイントを記載
- バージョン: 1.1.0 → 1.2.0 に更新
- 最終更新日: 2026-02-27

**スタンプ獲得方法セクション修正:**
```markdown
**アンケート回答報酬:**
- 患者満足度アンケート等に回答すると30個のスタンプを付与
- アンケートごとに1回のみ回答可能（重複防止）
- 回答報酬は来院回数にカウントされません
```

**Doc/02_ファイル構成.md**

**追加内容:**
- `components/survey/` フォルダ構成（SurveyModal, SurveyForm, SurveyCompleted, StarRating, NPSScale）
- `supabase/017_create_survey_tables.sql`
- `supabase/018_fix_survey_reward_trigger.sql`

**最近のアップデート履歴に追加:**
```markdown
| 2026-02-27 | **スタンプ履歴表示改善**: "+XX個獲得（合計 YY個）"形式に変更、取得方法別アイコン・色分け対応 |
| 2026-02-27 | **アンケート報酬バグ修正（重要）**: survey_rewardが来院回数にカウントされないよう018マイグレーション実行 |
| 2026-02-26 | **アンケート機能実装**: surveys/survey_questions/survey_responsesテーブル、SurveyModal/SurveyForm等コンポーネント追加 |
```

### 動作確認

**アンケート報酬バグ修正:**
- ✅ アンケート回答で30個（3個ではない）のスタンプが付与される
- ✅ visit_count が増加しない
- ✅ last_visit_date が更新されない
- ✅ stamp_count は正しく増加（MAX(stamp_number)）

**スタンプ履歴表示:**
- ✅ "+10個獲得（合計 XX個）"形式で表示される
- ✅ 取得方法ラベルが正しく表示される（来院、アンケート報酬、スタッフ操作、データ移行）
- ✅ アイコンが取得方法に応じて変わる
- ✅ 色分けが正しく機能する
- ✅ 「XX回目の来院」表示が削除されている

**データ整合性:**
- ✅ 既存のスタンプ履歴も正しく表示される
- ✅ amount = null のレコードも表示される（0個獲得として）
- ✅ 新旧データが混在しても問題なく動作する

### トラブルシューティング履歴

**問題: visit_count の更新が抜けていた**
- 発見者: ユーザー
- 症状: 018マイグレーションに visit_count 更新がなかった
- 解決: ユーザーが直接ファイルを修正し、008の元実装を参照して追加

**問題: ドキュメント不整合**
- 症状: Doc/03とDoc/05に'survey_reward'が記載されていない
- 解決: 両ドキュメントのstamp_method定義に追加

### ビルド確認

- ✅ TypeScript型チェック成功（`npx tsc --noEmit`）
- ✅ 環境変数変更なし
- ✅ データベーススキーマ変更: 018マイグレーション実行が必要

### デプロイ注意事項

**必須手順:**
1. Supabase SQL Editorで `supabase/018_fix_survey_reward_trigger.sql` を実行
2. Vercelにデプロイ（コードのみ、環境変数変更なし）
3. ブラウザキャッシュクリア推奨

**確認事項:**
- アンケート回答後、visit_countが増えないことを確認
- スタンプ履歴が新形式で表示されることを確認

### 関連ドキュメント

- **Doc/90_スタンプ履歴表示改善仕様.md**: 包括的な設計書
- **Doc/100_主な機能一覧（クライアント説明用）.md**: アンケート機能追加
- **Doc/02_ファイル構成.md**: survey関連ファイル追加
- **Doc/03_機能仕様書.md**: stamp_method定義更新
- **Doc/05_Database_Schema.md**: stamp_method定義更新

### 将来の拡張案

**アンケート機能:**
- アンケート結果の集計・分析ダッシュボード
- 複数アンケートの管理（期間限定、対象者限定）
- NPS（Net Promoter Score）の自動計算
- 自由記入欄のテキスト分析（キーワード抽出）

**スタンプ履歴表示:**
- フィルター機能（「すべて」「来院のみ」「アンケート」「スタッフ操作」）
- ソート機能（日時順、獲得数順）
- 月別・年別の集計表示
- エクスポート機能（CSV、PDF）

---



## 2026-02-27 (続き): 訪問回数とスタンプ獲得回数の分離表示

### 概要

スタンプ履歴表示改善の実装後、「訪問回数」の表示に問題が発見され、修正を実施。

**実装期間**: 2026-02-27（午後）

### 問題の発見

**問題:**
- スタンプカウンターセクション右上に「訪問回数: XX回」と表示
- しかし実際には `stampHistory.length`（全スタンプ獲得履歴の件数）を使用
- アンケート報酬やスタッフ操作も含まれ、実際の来院回数と一致しない

**ユーザーからの指摘:**
> 「訪問回数は visit_countを使う。」

**現状の表示:**
```typescript
<p className="text-xs text-gray-500">
  訪問回数: {stampHistory.length}回  // ← 問題：全履歴の件数
</p>
```

### 解決策

**データソースの整理:**
1. **訪問回数**: `profiles.visit_count` を使用
   - データベーストリガーで自動計算（amount = 10 のレコードのみカウント）
   - 実際の来院回数を正確に反映

2. **スタンプ獲得回数**: `stampHistory.length` を使用
   - すべてのスタンプ獲得履歴の件数
   - QRスキャン、アンケート報酬、スタッフ操作、データ移行すべてを含む

### 実装内容

#### 1. lib/stamps.ts に `fetchVisitCount()` 関数を追加

**lib/stamps.ts（追加）:**
```typescript
/**
 * ユーザーの訪問回数を取得（profilesテーブルから）
 * @param userId LINEユーザーID
 * @returns 訪問回数
 */
export const fetchVisitCount = async (userId: string): Promise<number> => {
  try {
    const { data, error } = await supabase
      .from("profiles")
      .select("visit_count")
      .eq("id", userId)
      .single();

    if (error) {
      console.error("❌ 訪問回数の取得に失敗しました:", error);
      return 0;
    }

    return data?.visit_count ?? 0;
  } catch (err) {
    console.error("❌ 予期しないエラー:", err);
    return 0;
  }
};
```

#### 2. components/(adult)/AdultStampPage.tsx の修正

**変更点:**

1. **stateの追加:**
```typescript
const [visitCount, setVisitCount] = useState(0);
```

2. **インポートの追加:**
```typescript
import {
  fetchStampCount,
  fetchVisitCount,  // 追加
  fetchStampHistory,
  // ...
} from "@/lib/stamps";
```

3. **fetchHistory 関数の修正:**
```typescript
const fetchHistory = async () => {
  if (!profile?.userId) return;

  setIsLoading(true);
  try {
    const count = await fetchStampCount(profile.userId);
    setStampCount(count);

    // 訪問回数を取得（追加）
    const visits = await fetchVisitCount(profile.userId);
    setVisitCount(visits);

    const history = await fetchStampHistory(profile.userId);
    setStampHistory(history);
  } catch (error) {
    console.error("❌ スタンプ履歴の取得エラー:", error);
  } finally {
    setIsLoading(false);
  }
};
```

4. **UI表示の修正:**
```typescript
<div className="text-right text-xs text-gray-500">
  <p>訪問回数: {visitCount}回</p>
  <p className="mt-0.5">スタンプ獲得: {stampHistory.length}回</p>
</div>
```

### 表示例（実装後）

**スタンプカウンターセクション:**
```
現在のスタンプ数              訪問回数: 5回
                            スタンプ獲得: 8回

         53
        / 10個
```

**データの意味:**
- **訪問回数 (5回)**: 実際の来院回数（QRスキャンのみ）
- **スタンプ獲得 (8回)**: すべてのスタンプ獲得アクション（来院5回 + アンケート3回）

### ビルド確認

- ✅ TypeScript型チェック成功（`npx tsc --noEmit`）
- ✅ Next.jsビルド成功（11.6秒）
- ✅ 環境変数変更なし
- ✅ データベーススキーマ変更なし

### 関連ドキュメント

- **Doc/90_スタンプ履歴表示改善仕様.md**: 訪問回数表示機能の追加内容を記載
- **Doc/02_ファイル構成.md**: stamps.tsの関数リストを更新

---

## 2026-03-01: スロットゲーム改善 + 子供画面スタンプ表示刷新

### 概要
スロットゲームの実用化（スタンプ自動付与）と子供画面のUX改善を実施。
合わせて React 18 StrictMode 起因のスタンプ重複挿入バグを修正。

---

### 1. スロットリール速度調整

**変更ファイル**: `app/slot/page.tsx`

- `speedRef.current = 18` → `9`（約半速）
- ユーザー体験: 速すぎてタイミングが取れないという問題を解消

---

### 2. スロットゲームルール.md 修正

**変更ファイル**: `Doc/04_スロットゲームルール.md`

コード実装と仕様書の乖離を解消:
- 全ゾロ目（非ジャックポット）の付与スタンプ数: 3個 → **5個**（コードに合わせる）
- 存在しない特殊パターン（🍎🌸🍀）を削除
- 「おしい！」条件（隣接2つ一致 = 1個）を追記
- 結果メッセージをコード文字列と一致させる
- 壊れたテーブル行を修正

---

### 3. スロットゲーム スタンプ付与機能実装

#### 新規API: `app/api/stamps/slot/route.ts`

```
POST /api/stamps/slot
Body: { userId: string, stamps: number }
```

- `profiles.stamp_count` を取得し `stamp_number = 現在値 + stamps` を計算
- `stamp_history` に INSERT（stamp_method: "slot_game"）
- DB トリガーが `profiles.stamp_count` を自動更新
- 1日の回数制限なし（何度でもプレイ可能）

#### 型・ラベル追加

| ファイル | 変更内容 |
|---|---|
| `types/stamp.ts` | `stamp_method` ユニオンに `"slot_game"` 追加 |
| `lib/stamps.ts` | `getStampMethodLabel()` に `case "slot_game": return "スロットゲーム"` 追加 |

#### スロットページ UI 更新（`app/slot/page.tsx`）

- `useViewMode()` を追加し `selectedChildId` を取得
- `targetUserId = selectedChildId ?? profile?.userId` でスタンプ付与先を決定
  - 子供画面経由（selectedChildId あり）→ 子供のプロフィールIDにスタンプ付与
  - 通常（selectedChildId なし）→ LINEログインユーザーIDにスタンプ付与
- 新 state: `stampAwarded`, `isAwarding`
- 新 callback: `awardSlotStamps(stamps)`
- `checkResult` でスタンプ数を決定し `awardSlotStamps` を呼び出し:
  - だいあたり（TOOTH×3）: 8個
  - あたり（その他ゾロ目）: 5個
  - おしい・はずれ: 1個
- UI: 付与中は「スタンプ つけてるよ...」、完了後は「🌟 N こ スタンプ ゲット！」

---

### 4. 子供画面 スタンプ履歴表示刷新

**変更ファイル**: `components/(kids)/KidsStampPage.tsx`

#### 履歴セクション（大人モードと構造統一）

| 変更前 | 変更後 |
|---|---|
| タイトル「📅 びょういんに きた ひ」 | 「🌟 スタンプ りれき」 |
| 来院日のみ表示 | +N こ ゲット！（ぜんぶで N こ） + 取得方法 + 日付 |
| 最新5件のみ | 全件表示 |
| Lucide アイコン | 絵文字アイコン（🏥/🎰/📝/👨‍⚕️） |

取得方法と絵文字の対応:

```
qr_scan       → 🏥 びょういん に きたよ！
slot_game     → 🎰 スロット で ゲット！
survey_reward → 📝 アンケート ほうしゅう
manual_admin  → 👨‍⚕️ せんせい から
```

---

### 5. 子供画面 スタンプカード デザイン刷新

**変更ファイル**: `components/(kids)/KidsStampPage.tsx`

10個でカードが埋まってしまう問題を解消するため、3セクション構成に変更:

#### セクション 1: トータルスタンプ
- 累積スタンプ数を大きく表示（`fullStamps` こ）
- 「いままでに あつめた ぜんぶの スタンプ」

#### セクション 2: 現サイクル進捗（0〜9 / 10）
- 10マスのドット表示（⭐ / ○）
- プログレスバー
- 残りN個でごほうびのメッセージ

```typescript
const currentCycleStamps = fullStamps % STAMP_GOAL; // 0-9
const completedCycles = Math.floor(fullStamps / STAMP_GOAL);
const remaining = currentCycleStamps === 0 ? STAMP_GOAL : STAMP_GOAL - currentCycleStamps;
```

#### セクション 3: 達成トロフィー
- `completedCycles` 回数分の 🏆 を表示（最大5個まで、それ以上は "+N" 表示）
- 0回の場合は励ましメッセージを表示

---

### 6. バグ修正: スタンプ重複挿入（React StrictMode）

**変更ファイル**: `app/slot/page.tsx`

#### 原因

```typescript
// 修正前（問題のあるコード）
const handleStop = useCallback((index, symbol) => {
  setStoppedReels((prev) => {
    const next = [...prev];
    next[index] = symbol;
    setTimeout(() => checkResult(next), 50); // ← state updater 内で副作用
    return next;
  });
}, [checkResult]);
```

React 18 StrictMode は `useState` の関数型アップデーターを**2回呼び出し**（純粋性チェック）。
`setTimeout` が2回スケジュール → `checkResult` が2回実行 → `awardSlotStamps` が2回呼ばれる → DB に重複挿入。

#### 修正内容

1. **`stoppedReelsRef`** を追加: state updater 外でリール停止状態を管理
2. **`handleStop`** を修正: ref を先に更新し、`setTimeout` を **state updater の外**に移動
3. **`isAwardingRef`** を追加: `awardSlotStamps` の二重実行を防ぐ排他ガード
4. **`spin()`** にリセット処理を追加

```typescript
// 修正後
const stoppedReelsRef = useRef<(string | null)[]>([null, null, null]);
const isAwardingRef = useRef(false);

const handleStop = useCallback((index, symbol) => {
  const next = [...stoppedReelsRef.current];
  next[index] = symbol;
  stoppedReelsRef.current = next;       // ref を先に更新
  setStoppedReels([...next]);            // state は UI 更新用
  setTimeout(() => checkResult(next), 50); // updater の外でスケジュール
}, [checkResult]);

const awardSlotStamps = useCallback(async (stamps) => {
  if (isAwardingRef.current) return;     // 二重呼び出し防止
  isAwardingRef.current = true;
  // ...
}, [targetUserId]);
```

**効果**: `handleStop` 自体は `requestAnimationFrame` コールバックから1回だけ呼ばれるため、`setTimeout` も1回だけスケジュールされ重複挿入が解消される。

---

### 変更ファイル一覧

| ファイル | 変更種別 | 内容 |
|---|---|---|
| `app/slot/page.tsx` | 修正 | 速度調整・スタンプ付与・selectedChildId 対応・重複バグ修正 |
| `app/api/stamps/slot/route.ts` | **新規** | スロットスタンプ付与 API |
| `types/stamp.ts` | 修正 | `stamp_method` に `"slot_game"` 追加 |
| `lib/stamps.ts` | 修正 | `getStampMethodLabel()` に slot_game 追加 |
| `components/(kids)/KidsStampPage.tsx` | 修正 | 履歴表示刷新・スタンプカード刷新 |
| `Doc/04_スロットゲームルール.md` | 修正 | コードと仕様書の整合性修正 |

---

