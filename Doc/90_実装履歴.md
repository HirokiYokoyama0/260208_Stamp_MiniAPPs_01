# 実装サマリー

各日の実装内容を時系列で記録。新しい作業はこのファイルの末尾に追記する。

---

## 2026-02-08: Phase 1 バックエンド基盤構築

### Supabase連携実装
- @supabase/supabase-js インストール、lib/supabase.ts 作成
- .env.local に SUPABASE_URL, SUPABASE_ANON_KEY 設定

### データベース設計
- profilesテーブル作成（001_create_profiles_table.sql）
- id を TEXT型（LINEユーザーID直接格納）で設計
- RLS設定、インデックス作成

### ユーザー情報の自動保存
- LINEログイン時に profiles へ UPSERT（id, line_user_id, display_name, picture_url）
- updated_at を自動更新

### 画面表示機能
- スタンプ数（stamp_count）のリアルタイム表示
- 診察券番号（ticket_number）表示（未登録時は「未登録」）
- 最終アクセス日時（updated_at）を日本語フォーマットで表示

### セキュリティ対応
- Next.js 15.1.0 → 16.1.6（CVE-2025-66478 脆弱性対応）
- React 19.0.0 → 19.2.4
- .gitignore に .claude, .env.local 追加

---

## 2026-02-09: Phase 2 スタンプ機能 + Phase 2.5 特典交換システム

### データベース拡張

**stamp_historyテーブル（002_create_stamp_history_table.sql）:**
- 1ユーザー:N個のスタンプ（1:N関係）
- QRコードIDで重複防止
- トリガー関数 `update_profile_stamp_count()` で profiles.stamp_count を自動計算

**rewards / reward_exchangesテーブル（003_create_rewards_tables.sql）:**
- rewards: 特典マスター（歯ブラシセット5個、フッ素塗布10個、クリーニング半額15個、ホワイトニング30%OFF 20個）
- reward_exchanges: 交換履歴（status: pending/completed/cancelled）

### データアーキテクチャ: Single Source of Truth
- profiles.stamp_count がスタンプ数の唯一の真実
- stamp_history INSERT → トリガー → profiles.stamp_count 自動更新
- 診察券ページとスタンプページでデータ不整合なし

### スタンプ登録API
- POST /api/stamps: QRスキャン → stamp_history INSERT → 重複チェック（同日同QR）
- lib/stamps.ts: fetchStampCount, fetchStampHistory, addStamp 等
- types/stamp.ts: StampHistoryRecord, AddStampResponse, StampProgress

### スタンプページ完全実装（app/stamp/page.tsx）
- スタンプカウンター、プログレスバー、来院履歴リスト、QRスキャン

### 特典交換システム
- GET /api/rewards: 有効な特典一覧取得
- POST /api/rewards/exchange: スタンプ積み上げ式（スタンプは減らない）
- app/rewards/page.tsx: 特典一覧、交換可否判定、交換処理
- lib/rewards.ts, types/reward.ts

### ボトムナビゲーション拡張
- 4つ → 5つ（診察券/スタンプ/特典/ケア記録/医院情報）
- アイコン20px、ラベル10px、flex-1でタップ領域均等配分

### スタッフ手動スタンプ機能強化
- 2ステップUI（認証 → 編集）、+/-ボタン
- POST /api/stamps/manual: newStampCount パラメータ追加
- 1日1回制限解除、監査証跡を stamp_history に記録

### バージョン管理自動化
- scripts/update-version.mjs: Gitタグから自動バージョン取得
- next.config.mjs: NEXT_PUBLIC_APP_VERSION として埋め込み
- prebuild フックで package.json を自動更新

### 仕様変更（v1.1）
- スタンプ消費型 → 積み上げ式に変更（2026-02-09）
- 条件を満たせば何度でも特典交換可能

---

## 2026-02-09: LINE友だち登録機能

### データベース
- profiles.is_line_friend カラム追加（004_add_is_line_friend_column.sql）
- BOOLEAN型、デフォルト NULL（未確認）

### 実装
- hooks/useLiff.ts: liff.getFriendship() で友だち状態取得、Supabaseにキャッシュ
- components/features/FriendshipPromptModal.tsx: 友だち登録促進モーダル
- AppLayout.tsx: 初回起動時にモーダル表示（1日1回、2秒遅延）
- AdultInfoPage.tsx: 友だち登録状態に応じた表示切替
- 友だち追加URL: https://line.me/R/ti/p/@550mlcao

---

## 2026-02-11: 子供用モード基盤（Kids Mode Phase 1）

### フォルダ構成リファクタリング
- 既存ページUIを components/(adult)/AdultXxx.tsx に抽出（5ファイル）
- components/(kids)/KidsXxx.tsx をプレースホルダーとして作成（5ファイル）
- QRScanner, StaffPinModal を features/ → shared/ に移動

### ViewModeContext（表示モード管理）
- contexts/ViewModeContext.tsx: adult/kids 切替、Supabase profiles.view_mode と同期
- types/viewMode.ts: ViewMode 型定義
- デフォルト 'adult'、エラー時もクラッシュしない

### ページルーティング変更
- 全5ページを共通パターンに書き換え: useViewMode() → Adult/Kids 分岐

### 設定ページ
- app/settings/page.tsx: 大人用/子供用モード切替ボタン

### Tailwind CSS拡張
- kids カラー5色: kids-pink, kids-yellow, kids-green, kids-blue, kids-purple
- kids フォント: "M PLUS Rounded 1c"

### Supabaseマイグレーション
- 005_add_view_mode_column.sql: profiles.view_mode カラム追加

### 子供用医院情報ページ
- KidsInfoPage.tsx: 全セクションひらがな表記、kidsカラー5色で色分け
- 設定ページへのリンク（モード切替用）

### ハブラーシカ画像
- public/images/haburashika.jpg に配置
- KidsStampPage で使用（120x120）

### 子供用スロットゲームボタン
- components/shared/KidsSlotButton.tsx: 子供モード時のみフローティング表示
- app/slot/page.tsx: プレースホルダー
- ボトムナビ左上に固定配置（bottom-[72px] left-4）

### その他
- 設定ページの alert() 削除
- ファイル構成.md 全面更新

### デプロイ注意
- 推奨順: SQL（005）→ Vercelデプロイ
- 逆順でもクラッシュしないが、設定ページのモード切替が機能しない

---

## 2026-02-12: テスト環境構築 / Doc整理

### LIFF環境分離（本番 / テスト）
- **本番用（Vercel）**: `NEXT_PUBLIC_LIFF_ID=2009075851-74EieWb4`
- **テスト用（ngrok）**: `NEXT_PUBLIC_LIFF_ID=2009075851-kflzDQLr`
- `.env.local` でコメントアウト切替で管理
- テスト時は ngrok で `https://xxx.ngrok-free.dev` → `localhost:3000` にトンネル

### ngrok導入
- winget でインストール（v3.36.0）
- authtoken 設定済み

### Doc フォルダ整理
- Implementation_Summary 3ファイル → 1ファイルに統合（追記型）
- Feature_Specifications 4ファイル → 1ファイルに統合（スタンプ/特典/スタッフ操作/友だち登録）
- 10ファイルを Doc/archive/ に移動
- Doc直下: 15ファイル → 7ファイル + archive に集約
- ファイル構成.md を新構成に更新

---

## 2026-02-14: 次回メモ機能実装

### 概要
受付スタッフが患者ごとに「次回来院予定日」と「カスタムメッセージ」を設定できる機能。患者のLINEミニアプリのホーム画面に表示される。

### データベース実装
**マイグレーション（006_add_next_memo_columns.sql）:**
- profiles テーブルに3つのカラム追加：
  - `next_visit_date` (DATE): 次回来院予定日
  - `next_memo` (TEXT): カスタムメッセージ（最大200文字）
  - `next_memo_updated_at` (TIMESTAMPTZ): 最終更新日時
- 部分インデックス作成（next_visit_date が NULL でない行のみ）
- 自動更新トリガー追加：
  - `update_next_memo_timestamp()` 関数: next_visit_date または next_memo 変更時に next_memo_updated_at を自動更新
  - `trigger_update_next_memo_timestamp` トリガー: BEFORE UPDATE で実行

### API実装
**新規エンドポイント:**
- `GET /api/users/[userId]/memo`: ユーザーの次回メモを取得
- `PUT /api/users/[userId]/memo`: ユーザーの次回メモを更新
  - バリデーション: 日付形式（YYYY-MM-DD）、文字数制限（200文字）

**ファイル:**
- `app/api/users/[userId]/memo/route.ts`: API実装
- `types/memo.ts`: 型定義（UserMemo, UpdateUserMemoRequest, UpdateUserMemoResponse）
- `lib/memo.ts`: ヘルパー関数（fetchUserMemo, updateUserMemo, formatVisitDate）

### フロントエンド実装
**患者側表示（AdultHome.tsx）:**
- ハブラーシカメッセージセクションの内容を動的に生成
- 4つの表示パターン：
  1. 日付あり + メモあり: 「次回の定期検診は○年○月○日です。<br>カスタムメッセージ」
  2. 日付あり + メモなし: 「次回の定期検診は○年○月○日です。」
  3. 日付なし + メモあり: 「カスタムメッセージ」のみ
  4. どちらもなし: デフォルトメッセージ
- データ取得: ログイン時、スタンプ獲得後、特典交換後に自動取得

**管理画面（/admin/memo）:**
- 簡易編集画面を作成（Phase 7で本格管理画面に統合予定）
- 入力項目:
  - ユーザーID（LINE User ID）
  - 次回来院予定日（日付ピッカー）
  - カスタムメッセージ（テキストエリア、200文字制限）
- リアルタイムプレビュー機能
- 保存 / クリアボタン

### 技術的な改善
**タイムゾーン問題の修正:**
- `new Date("2026-04-13")` はタイムゾーンによって前日になる問題を修正
- 文字列を直接分解する方式に変更: `split('-').map(Number)`
- lib/memo.ts の `formatVisitDate()` 関数で実装

**バリデーション強化:**
- API側で200文字制限を強制（app/api/users/[userId]/memo/route.ts:120-135）
- フロントエンドだけでなくバックエンドでも検証

**自動更新トリガー:**
- next_memo_updated_at の手動更新が不要に
- データベーストリガーで自動管理

### セキュリティ
- 現状は認証なしの簡易管理画面（/admin/memo）
- Phase 7で本格的なスタッフ認証を実装予定
- 本番環境ではIP制限またはBasic認証を推奨

### ドキュメント更新
- 03_機能仕様書.md: 5章「次回メモ機能」を追加
- 90_実装履歴.md: 本セクションを追加
- 10_TODO.md: 次回メモ機能を完了済みタスクに追加予定

### 将来の拡張案
- ユーザー検索機能（名前・診察券番号で検索）
- メッセージテンプレート機能
- 変数置換機能（{name}, {stamp_count} など）
- 一括設定機能（全患者向けお知らせ）
- LINE通知連携（予定日の3日前に自動通知）

---

## 2026-02-14: 予約ボタンクリック数トラッキング機能

### 概要
患者が「予約する」ボタンをクリックした回数を記録し、後から統計分析できるようにする機能。スタンプ数と予約ボタンクリック数の相関分析や、再来院促進施策の効果測定に活用する。

### 設計方針
**シンプル設計:**
- 単純な累積カウンター（履歴テーブルなし）
- profiles.reservation_button_clicks カラム（INTEGER）で管理
- 増加のみ（減少処理なし）

**UX優先:**
- エラーでもユーザー体験を妨げない
- fetch を await せず非同期で実行
- .catch() でエラーを握りつぶす（コンソールログのみ）

### データベース実装
**マイグレーション（007_add_reservation_clicks.sql）:**
- profiles テーブルに `reservation_button_clicks` カラム追加（INTEGER, DEFAULT 0）
- インデックス作成（idx_profiles_reservation_clicks）
- PostgreSQL関数 `increment_reservation_clicks(p_user_id TEXT)` を作成：
  - DECLARE ブロックで new_count 変数を宣言
  - COALESCE で NULL 安全な +1 処理
  - RETURNING 句で更新後の値を取得
  - ユーザーが存在しない場合は 0 を返す

### API実装
**新規エンドポイント:**
- `POST /api/users/[userId]/reservation-click`: クリック数を+1する
  - リクエストボディ: 空
  - レスポンス: { success: boolean, message: string, clicks?: number }
  - エラーハンドリング: 400（不正なユーザーID）、404（ユーザー未存在）、500（DB エラー）

**ファイル:**
- `app/api/users/[userId]/reservation-click/route.ts`: API実装
- supabase.rpc('increment_reservation_clicks', { p_user_id }) でDB関数を呼び出し

### フロントエンド実装
**AdultHome.tsx:**
- `handleReservation()` 関数に7行追加
- 予約ボタンクリック時、APIエンドポイントを呼び出し
- fetch を await せず非同期実行
- .catch() でエラーを握りつぶす（console.error のみ）

**実装コード:**
```typescript
// 🆕 予約ボタンのクリック数をカウント
if (profile?.userId) {
  fetch(`/api/users/${profile.userId}/reservation-click`, {
    method: "POST",
  }).catch((error) => {
    // エラーでもユーザー体験は妨げない
    console.error("⚠️ クリックカウントエラー:", error);
  });
}
```

### データ分析
**統計クエリ（機能仕様書に記載）:**
1. スタンプ数とクリック数の相関分析
2. クリック率でユーザー分類（高頻度/標準/低頻度）
3. 再来院率の計測（最終来院日ベース）
4. スタンプ段階別のクリック率

### 将来の拡張案
- クリック履歴テーブル追加（日時、デバイス情報などを記録）
- 予約完了フラグとの連携（クリック→実際に予約したかを追跡）
- A/Bテスト機能（ボタン文言やデザインの効果測定）
- プッシュ通知の効果測定（通知送信後のクリック増加率）

### ドキュメント更新
- 03_機能仕様書.md: 6章「予約ボタンクリック数トラッキング機能」を追加
- 90_実装履歴.md: 本セクションを追加
- 10_TODO.md: 予約ボタンクリック機能を完了済みタスクに追加

---

## 2026-02-17: Phase 2 家族紐付け機能実装完了

### 概要
親子で協力してスタンプを貯める「家族連携機能」を実装。初回登録時に親（保護者）または子（メンバー）を選択し、招待コードで家族に参加できる。

**実装期間**: 2026-02-17（1日で完了）

### データベース実装

**マイグレーション（009_add_family_support.sql）:**
- **familiesテーブル新規作成**:
  - id (TEXT, PRIMARY KEY): 家族ID（招待コードとして使用）
  - family_name (TEXT): 家族名
  - representative_user_id (TEXT): 代表者（親）のユーザーID
  - created_at, updated_at (TIMESTAMPTZ)
- **profilesテーブル拡張**:
  - family_id (TEXT, FOREIGN KEY → families.id)
  - family_role (TEXT): 'parent' または 'child'
  - CHECK制約で値を制限
- **family_stamp_totalsビュー**:
  - 家族ごとのスタンプ合計を自動集計
  - family_id, family_name, member_count, total_stamp_count, total_visit_count
- **トリガー関数**:
  - `update_families_updated_at()`: families.updated_at を自動更新
- **RLS ポリシー**:
  - すべて `USING (true)` に設定（APIレイヤーでアクセス制御）

**マイグレーション（009_fix_rls_policies.sql）:**
- `auth.uid()` を使用したRLSポリシーを削除
- 理由: LINE認証を使用しており、Supabase Authを使っていないため型エラーが発生
- 管理ダッシュボードからのアクセスも考慮

**型の統一（重要）:**
- `families.id` を UUID → TEXT に変更
- `profiles.id` が TEXT型（LINE User ID）のため、外部キー制約の型を統一
- UUID生成は `gen_random_uuid()::TEXT` で対応

### API実装（6本）

**1. GET /api/users/me:**
- ユーザー情報 + 家族情報を取得
- Supabaseの JOIN クエリで families テーブルも取得
- family_role が NULL の場合は /onboarding へリダイレクト

**2. POST /api/users/setup-role:**
- 初回登録時のロール設定
- 親の場合: 新規家族を自動作成（family_name: "〇〇の家族"）
- 子の場合: family_role のみ設定、/family/join へリダイレクト

**3. POST /api/families/join:**
- 子どもが招待コードで家族に参加
- inviteCode（families.id）で家族を検索
- profiles.family_id を更新

**4. GET /api/families/me:**
- 家族詳細 + メンバー一覧を取得
- family_stamp_totals ビューから家族合計スタンプを取得
- メンバーごとのスタンプ数・訪問回数も取得

**5. PATCH /api/families/update:**
- 家族名の変更（親専用）
- family_role === 'parent' のチェック
- families.family_name を更新

**6. DELETE /api/families/members:**
- メンバーの削除（親専用、子のみ削除可能）
- profiles.family_id を NULL に設定
- 親自身は削除不可

### UI実装（3ページ + 設定画面修正）

**1. app/onboarding/page.tsx（初回ロール選択画面）:**
- 親（User アイコン）/ 子（Baby アイコン）の2択ボタン
- useLiff() でLINEユーザー情報取得
- POST /api/users/setup-role でロール設定
- 親 → / へ、子 → /family/join へリダイレクト

**2. app/family/join/page.tsx（家族参加画面）:**
- 招待コード入力フィールド
- クリップボードから貼り付けボタン（navigator.clipboard.readText）
- POST /api/families/join で家族参加
- 成功時 → / へリダイレクト
- ヘルプセクション: 招待コードの取得方法を説明
- QRコード読み取りボタン（将来実装用、現在は disabled）

**3. app/family/manage/page.tsx（家族管理画面・親専用）:**
- 家族名のインライン編集（編集モード切替）
- 招待コードの表示 + コピーボタン
- メンバー一覧カード表示（display_name, スタンプ数, ロール）
- 子の削除ボタン（確認ダイアログ付き）
- calculateStampDisplay() で10倍システムに対応

**4. app/settings/page.tsx（設定画面修正）:**
- 「家族管理」セクションを追加
- Users アイコン付きボタン
- ロールに応じた説明文の出し分け:
  - parent: 「家族メンバーの管理や招待コードの確認」
  - child: 「家族への参加」
  - 未設定: 「家族機能を設定」
- クリック時の遷移先振り分け:
  - parent → /family/manage
  - child → /family/join
  - 未設定 → /onboarding

### テスト環境構築

**ローカル開発環境:**
- Next.js開発サーバー: ポート4000で起動
- ngrokトンネル: `npx ngrok http 4000`
- トンネルURL: https://vibrioid-jolyn-polyphonically.ngrok-free.dev
- LIFF設定: エンドポイントURLを更新（テスト用LIFF ID: 2009075851-kflzDQLr）

**デバッグログ追加:**
- `hooks/useLiff.ts`: LIFF初期化の各ステップにconsole.log追加
- `contexts/ViewModeContext.tsx`: プロフィール取得処理にログ追加
- ブラウザコンソールで動作確認が容易に

### トラブルシューティング履歴

**問題1: 型の不一致エラー（profiles.id vs families.id）**
- 症状: profiles.id は TEXT だが families.id が UUID で外部キー制約エラー
- 解決: families.id を TEXT に変更、gen_random_uuid()::TEXT で生成

**問題2: RLS ポリシーで auth.uid() 型エラー**
- 症状: auth.uid() は UUID を返すが profiles.id は TEXT
- 解決: RLS ポリシーを `USING (true)` に簡略化（APIレイヤーで制御）

**問題3: 管理ダッシュボードからのアクセス制限**
- 症状: 厳格なRLSポリシーだと管理画面から操作不可
- 解決: Service Role Key使用時は全アクセス可能に（`USING (true)`）

**問題4: Next.jsサーバー起動エラー（ロックファイル）**
- 症状: .next/dev/lock ファイルが残りポート4000で起動失敗
- 解決: 既存nodeプロセスを確認、適切に終了してから再起動

**問題5: ngrokが3000番ポートに接続**
- 症状: ngrokが意図しないポート（3000）に接続
- 解決: 明示的に `npx ngrok http 4000` で指定

### 技術的な設計判断

**1. TEXT型の採用理由:**
- LINE User IDがUUID形式ではない（"U" + 32文字の英数字）
- 一貫性のため families.id も TEXT 型に統一
- 招待コードとしても利用（そのまま表示可能）

**2. RLS ポリシーの簡略化:**
- LINE認証を使用（Supabase Authは未使用）
- 管理ダッシュボードでのアクセスも必要
- アクセス制御はAPIレイヤーで実装（family_role チェック）

**3. 積み上げ式スタンプシステムとの整合性:**
- family_stamp_totals ビューで自動集計
- メンバーの profiles.stamp_count を SUM() するだけ
- リアルタイムで家族合計が更新される

**4. 招待コードの設計:**
- families.id をそのまま招待コードとして使用
- UUIDをTEXT化した文字列（36文字）
- 将来的にQRコード化も容易

### ファイル一覧

**データベース:**
- `supabase/009_add_family_support.sql`
- `supabase/009_fix_rls_policies.sql`

**API:**
- `app/api/users/me/route.ts`
- `app/api/users/setup-role/route.ts`
- `app/api/families/join/route.ts`
- `app/api/families/me/route.ts`
- `app/api/families/update/route.ts`
- `app/api/families/members/route.ts`

**UI:**
- `app/onboarding/page.tsx`
- `app/family/join/page.tsx`
- `app/family/manage/page.tsx`
- `app/settings/page.tsx`

**ドキュメント:**
- `Doc/22_Phase2_実装計画書.md`
- `Doc/23_データベーススキーマ現状.md`
- `Doc/90_実装履歴.md`（本ファイル）

### 将来の拡張案（Phase 3以降）

1. **QRコードでの家族参加**
   - 招待コードをQRコード化
   - カメラで読み取って自動参加

2. **家族招待メッセージ**
   - LINEメッセージで招待リンクを送信
   - 「○○さんから家族に招待されました」

3. **家族ランキング**
   - 家族単位でのスタンプランキング
   - 月間TOP10表示

4. **複数の親（共同管理）**
   - representative_user_id を配列化
   - 夫婦で共同管理

5. **家族イベント**
   - 家族全員が来院したらボーナススタンプ
   - 家族限定の特典

### セキュリティ考慮事項

- 招待コードは36文字のランダム文字列（推測困難）
- family_role チェックは全APIで実施
- 親のみが編集・削除権限を持つ
- メンバーは自分の情報のみ参照可能

---

## 2026-02-17: 仮想メンバー機能実装完了

### 概要
スマートフォンやLINEアカウントを持たない子供のために、親が代理で登録・管理できる「仮想メンバー機能」を実装。親のスマホから子供専用のスタンプ画面を開き、スロットゲームも楽しめる。

**実装期間**: 2026-02-17（Phase 2実装完了直後、同日追加実装）

### 設計思想

**シンプル設計原則:**
- 新しいテーブルは作らない（既存のprofilesテーブルを活用）
- アカウント切り替え機能は作らない（直接子供モードを開く）
- 既存のKidsHomeコンポーネントを再利用
- 家族スタンプは個人スタンプの単純な合計（新しい概念を作らない）

**技術的実装:**
- 仮想メンバーは `line_user_id = NULL` で識別
- 手動生成ID: `manual-child-${randomUUID()}`
- LocalStorageで子供モード表示中の子供IDを管理

### データベース設計

**既存テーブル活用:**
```sql
-- 通常のメンバー（LINEアカウントあり）
INSERT INTO profiles VALUES (
  'U5c70cd61...',              -- LINE User ID
  'U5c70cd61...',              -- 同じ
  'Mio',
  '123456',
  NULL,
  30,  -- 3個
  3,
  '2026-02-15',
  'family-001',
  'child',
  'kids',
  NOW(),
  NOW()
);

-- 仮想メンバー（LINEアカウントなし）
INSERT INTO profiles VALUES (
  'manual-child-001',          -- 手動生成ID
  NULL,                        -- line_user_id = NULL
  '横山太郎',
  '123460',
  NULL,
  10,  -- 1個
  4,
  '2026-02-10',
  'family-001',
  'child',
  'kids',
  NOW(),
  NOW()
);
```

**識別方法:**
- `line_user_id IS NULL` → 仮想メンバー
- `line_user_id IS NOT NULL` → 実メンバー

### API実装（4本）

**1. POST /api/families/members/add:**
- 親が仮想子供メンバーを追加
- リクエスト: `{ userId, childName, ticketNumber }`
- 手動IDを生成: `manual-child-${randomUUID()}`
- profilesテーブルにINSERT（line_user_id = NULL）
- 家族紐付け: `family_id`, `family_role = 'child'`
- 権限チェック: `family_role === 'parent'` のみ実行可能

**2. PATCH /api/families/members/[memberId]:**
- 仮想子供メンバーの情報を編集
- リクエスト: `{ userId, childName, ticketNumber }`
- 名前と診察券番号を更新
- 権限チェック: 親のみ、同じ家族のメンバーのみ

**3. DELETE /api/families/members/[memberId]:**
- 仮想子供メンバーを削除
- 仮想メンバー（line_user_id = NULL）: profilesから完全削除
- 実メンバー（line_user_id != NULL）: family_idをNULLに（紐付け解除のみ）
- 権限チェック: 親のみ、同じ家族のメンバーのみ

**4. GET /api/profiles/[profileId]:**
- プロフィールIDでプロフィール情報を取得
- 仮想メンバーにも対応
- 子供モード画面で使用

**5. GET /api/families/me（修正）:**
- メンバー一覧に `line_user_id` と `ticket_number` を追加
- 仮想メンバーの識別に必要

### UI実装（3コンポーネント + 1ページ + 1修正）

**1. components/AddChildDialog.tsx（新規）:**
- 子供追加ダイアログコンポーネント
- 入力項目:
  - 名前（必須）
  - 診察券番号（任意）
- バリデーション: 名前の空文字チェック
- onSave コールバックで親コンポーネントに通知

**2. app/family/manage/page.tsx（大幅拡張）:**
- 「子供を追加」ボタン追加（親専用）
- メンバーカードに3つのボタン追加（仮想メンバーのみ）:
  - **開くボタン**: 子供モード画面へ遷移（LocalStorageにIDを保存）
  - **編集ボタン**: インライン編集モード（名前・診察券番号）
  - **削除ボタン**: 確認ダイアログ付き削除
- 仮想メンバーに「仮想」バッジ表示（紫色）
- インライン編集機能:
  - 編集モード切替（editingMember ステート管理）
  - 保存/キャンセルボタン
  - DOMから直接値を取得（getElementById）

**3. app/child-mode/page.tsx（新規）:**
- 仮想メンバー専用の子供モード画面
- LocalStorageから `currentChildId` を取得
- GET /api/profiles/[profileId] でプロフィール取得
- KidsHomeコンポーネントに profileOverride prop で渡す
- 戻るボタン: LocalStorageクリア → /family/manage へ
- カラフルな背景（グラデーション）

**4. components/(kids)/KidsHome.tsx（大幅実装）:**
- プレースホルダーから完全実装へ
- `profileOverride?: Profile` prop を追加
- プロフィール取得ロジック:
  - profileOverride がある場合: それを使用（仮想メンバー）
  - ない場合: useLiff() で通常のLIFFユーザー情報を取得
- スタンプカード表示（10個のマス、星アイコン）
- 進捗バー（カラフルなグラデーション）
- 励ましメッセージ（スタンプ数に応じて変化）
- スロットゲームボタン（/slotへのリンク）
- カラフルなデザイン（kids-pink, kids-yellow, kids-blue, kids-purple）

**5. app/slot/page.tsx（既存・変更なし）:**
- 歯科テーマのスロットゲーム
- タップで停止、3つ揃いで当たり
- 仮想メンバーも通常メンバーも同じゲームを楽しめる

### ユーザーフロー

**親の操作（仮想メンバー追加）:**
1. 設定 → 家族管理 → [+ 子供を追加]
2. ダイアログで名前と診察券番号を入力
3. [保存] → profilesに仮想メンバー追加
4. メンバー一覧に「仮想」バッジ付きで表示

**親の操作（子供モード開く）:**
1. 家族管理画面で仮想メンバーの [開く] ボタンをタップ
2. LocalStorageに currentChildId を保存
3. /child-mode へ遷移
4. 子供用のカラフル画面表示（ハブラーシカ、スタンプカード）
5. スロットゲームで遊べる
6. [かぞくかんりにもどる] で戻る

**親の操作（情報編集）:**
1. 家族管理画面で仮想メンバーの [編集] ボタンをタップ
2. インライン編集モードに切り替わり
3. 名前・診察券番号を修正
4. [保存] で PATCH /api/families/members/[memberId]

**親の操作（削除）:**
1. 家族管理画面で仮想メンバーの [削除] ボタンをタップ
2. 確認ダイアログ表示
3. [OK] で DELETE /api/families/members/[memberId]
4. profilesから完全削除

### 技術的な実装詳細

**LocalStorage利用:**
```typescript
// 子供モード開く時
localStorage.setItem('currentChildId', memberId);
router.push('/child-mode');

// 子供モード画面
const childId = localStorage.getItem('currentChildId');

// 戻る時
localStorage.removeItem('currentChildId');
router.push('/family/manage');
```

**KidsHomeのprofileOverride:**
```typescript
interface KidsHomeProps {
  profileOverride?: Profile; // 仮想メンバー用
}

export default function KidsHome({ profileOverride }: KidsHomeProps) {
  useEffect(() => {
    if (profileOverride) {
      // 仮想メンバー
      setDisplayName(profileOverride.display_name);
      setStampCount(profileOverride.stamp_count);
      return;
    }

    // 通常のLIFFユーザー
    if (liffProfile?.userId) {
      // Supabaseから取得
    }
  }, [profileOverride, liffProfile]);
}
```

**インライン編集の実装:**
```typescript
// 編集モード
const isEditingThis = editingMember?.id === member.id;

{isEditingThis ? (
  <div>
    <input id={`edit-name-${member.id}`} defaultValue={member.display_name} />
    <input id={`edit-ticket-${member.id}`} defaultValue={member.ticket_number || ''} />
    <button onClick={() => {
      const nameInput = document.getElementById(`edit-name-${member.id}`) as HTMLInputElement;
      const ticketInput = document.getElementById(`edit-ticket-${member.id}`) as HTMLInputElement;
      handleEditMember(member.id, nameInput.value, ticketInput.value);
    }}>保存</button>
  </div>
) : (
  // 通常表示
)}
```

### ファイル一覧

**API（新規）:**
- `app/api/families/members/add/route.ts`
- `app/api/families/members/[memberId]/route.ts`（PATCH + DELETE）
- `app/api/profiles/[profileId]/route.ts`

**API（修正）:**
- `app/api/families/me/route.ts`（メンバー一覧に line_user_id, ticket_number を追加）

**UI（新規）:**
- `components/AddChildDialog.tsx`
- `app/child-mode/page.tsx`

**UI（大幅修正）:**
- `app/family/manage/page.tsx`（子供追加・編集・削除・開くボタン追加）
- `components/(kids)/KidsHome.tsx`（プレースホルダーから完全実装へ）

**ドキュメント:**
- `Doc/25_仮想メンバー機能仕様書.md`（設計書、前の会話で作成）
- `Doc/90_実装履歴.md`（本ファイル）

### スタンプ付与について

**現状:**
- 仮想メンバーのスタンプ付与は未実装
- 親が子供モードを開いてもQRスキャンはできない

**将来の実装（Phase 3以降）:**
1. **子供モードでQRスキャン:**
   - KidsHomeにQRスキャンボタン追加
   - スキャン時にprofileOverride.idを使用してスタンプ付与

2. **親の管理画面から手動付与:**
   - 家族管理画面でスタッフピン認証
   - 仮想メンバーのスタンプ数を直接編集

3. **スタッフ側管理画面:**
   - Phase 7の管理ダッシュボードで一括管理
   - 診察券番号で検索して付与

### 動作確認項目

**追加機能:**
- [x] 親が「子供を追加」ボタンで仮想メンバーを追加できる
- [x] 名前と診察券番号を入力できる
- [x] メンバー一覧に「仮想」バッジ付きで表示される
- [x] 「開く」ボタンで子供モード画面が開く
- [x] 子供モード画面でスタンプカードが表示される
- [x] 「編集」ボタンで名前・診察券番号を修正できる
- [x] 「削除」ボタンで仮想メンバーを削除できる
- [x] LocalStorageが正しく管理される
- [x] スロットゲームへのリンクが機能する

**既存機能との整合性:**
- [x] 家族スタンプ合計に仮想メンバーのスタンプが含まれる
- [x] 実メンバーの削除は紐付け解除のみ（完全削除されない）
- [x] 仮想メンバーの削除は完全削除される
- [x] 親の権限チェックが正しく機能する

### 将来の拡張案

1. **スタンプ付与機能:**
   - 子供モード画面でQRスキャン機能
   - 親の管理画面から手動付与

2. **プロフィール画像:**
   - 仮想メンバーにアバター設定
   - 動物や乗り物のアイコンから選択

3. **子供専用ゲーム拡充:**
   - スロット以外のミニゲーム追加
   - スタンプ数に応じて解放

4. **子供専用メッセージ:**
   - 「次回は○月○日だよ！」
   - 全ひらがな表示

5. **複数の仮想メンバー管理:**
   - 一覧表示の最適化
   - ソート・フィルター機能

### セキュリティ考慮事項

- 仮想メンバーの操作は親（family_role = 'parent'）のみ可能
- 同じ家族のメンバーのみ操作可能（family_id チェック）
- 手動生成IDは推測困難（UUID使用）
- LocalStorageは同一ブラウザのみで有効（他人のアクセス不可）

### デプロイ注意事項

- データベーススキーマ変更なし（既存のprofilesテーブルのみ使用）
- 新規APIエンドポイント4本追加
- 環境変数変更なし
- Vercelへのデプロイは通常通り

---

## 2026-02-22: スマホなし子供機能の改善とバグ修正

### 概要
スマホを持たない子供（代理管理メンバー）の名前管理を`real_name`フィールドに統一し、キッズモード設定画面でlocalStorageキー名の不一致によるバグを修正。

**実装期間**: 2026-02-22

### 問題の発見

**問題1: データ項目の設計判断**
- ユーザーからの指摘: 「スマホなしの子供を追加するときは、display_nameではなくreal_nameに保存する必要がある」
- 理由: 
  - `display_name`: LINEの表示名または検索用（実際のLINEメンバー用）
  - `real_name`: 医療記録用の本名（代理管理メンバー用）
- スマホなし子供は医療機関での記録のため、実名管理が必須

**問題2: localStorageのキー名不一致**
- 症状: 子供モード設定画面で「子供IDが見つかりません」エラー
- 原因:
  - ViewModeContext: `selectedChildId` というキーで保存
  - キッズモード設定画面: `currentChildId` というキーで取得（❌ 間違い）
- 影響: 親が子供画面に切り替えても、設定画面が正しく動作しない

### データモデル設計の修正

**real_nameフィールドの活用:**
```typescript
// スマホあり（LINEメンバー）
{
  id: "U5c70cd61...",
  line_user_id: "U5c70cd61...",  // LINEアカウント
  display_name: "横山光紀",      // LINEの表示名
  real_name: null,                // 使用しない
}

// スマホなし（代理管理メンバー）
{
  id: "manual-child-xxx",
  line_user_id: null,             // LINEアカウントなし
  display_name: "すまほなしこ",   // 検索用・互換性用
  real_name: "すまほなしこ",     // 本名（実際の名前）★ こちらを使用
}
```

**表示ロジックの統一:**
- スマホなし子供: `real_name || "登録なし"` を表示
- `display_name`の有無に関わらず、`real_name`がなければ「登録なし」
- スマホあり子供: `display_name` を表示（従来通り）

### 修正したファイル

**1. app/api/families/members/add/route.ts**
- 仮想メンバー追加時に`real_name`にも保存
```typescript
.insert({
  id: virtualChildId,
  line_user_id: null,
  display_name: childName,  // 検索用・互換性用
  real_name: childName,     // 本名（実際の名前）★ 追加
  ticket_number: ticketNumber || null,
  // ...
})
```

**2. app/api/families/members/[memberId]/route.ts**
- 仮想メンバー編集時に両方更新
```typescript
if (childName !== undefined) {
  updateData.display_name = childName;  // 検索用・互換性用
  updateData.real_name = childName;     // 本名（実際の名前）★ 追加
}
```

**3. app/api/families/me/route.ts**
- メンバー一覧取得時に`real_name`も含める
```typescript
.select("id, display_name, real_name, family_role, stamp_count, visit_count, line_user_id, ticket_number")
```

**4. app/child-mode/settings/page.tsx（重要な修正）**
- **問題**: localStorageから`currentChildId`を取得していた
- **修正**: ViewModeContextから`selectedChildId`を直接取得
```typescript
// 修正前: localStorageを直接使用
const [childId, setChildId] = useState<string | null>(null);
const id = localStorage.getItem('currentChildId'); // ❌ 間違ったキー名

// 修正後: ViewModeContextから取得
const { selectedChildId, setSelectedChildId, setViewMode } = useViewMode();
if (!selectedChildId) {
  throw new Error('子供IDが見つかりません');
}
```

- `real_name`を優先して表示・保存
```typescript
// 取得時
setDisplayName(data.profile.real_name || data.profile.display_name || '');

// 保存時
.update({
  display_name: displayName.trim(),  // 検索用・互換性用
  real_name: displayName.trim(),     // 本名（実際の名前）
  ticket_number: ticketNumber.trim() || null,
})
```

**5. app/child-mode/page.tsx**
- localStorageキー名を統一（将来の互換性のため）
```typescript
// 修正前
const childId = localStorage.getItem('currentChildId');

// 修正後
const childId = localStorage.getItem('selectedChildId');
```

**6. components/(kids)/KidsHome.tsx**
- `real_name`を優先して表示
```typescript
// Supabaseクエリに real_name 追加
.select("stamp_count, display_name, real_name, ticket_number, next_visit_date, next_memo, family_id")

// 表示ロジック修正
setDisplayName(data.real_name || "登録なし");  // display_nameは使わない
```

**7. app/family/manage/page.tsx**
- FamilyMemberインターフェースに`real_name`追加
- 表示ロジックを仮想メンバーかどうかで分岐
```typescript
interface FamilyMember {
  id: string;
  display_name: string;
  real_name: string | null;  // 追加
  // ...
}

// 表示部分
{isVirtualChild ? (member.real_name || "登録なし") : member.display_name}
```

**8. app/settings/page.tsx**
- ProxyChildインターフェースに`real_name`追加
- 子供画面一覧で`real_name`を優先表示
```typescript
interface ProxyChild {
  id: string;
  display_name: string;
  real_name: string | null;  // 追加
  stamp_count: number;
}

// 表示部分
子供の画面：{child.real_name || child.display_name || "登録なし"}
```

**9. components/layout/AppLayout.tsx**
- TypeScript型エラー修正（kidsHrefプロパティ）
```typescript
const TABS = [
  { href: "/", label: "診察券", icon: CreditCard, kidsHref: undefined },
  // ... 他のタブも同様
  { href: "/settings", label: "設定", icon: Settings, kidsHref: "/child-mode/settings" },
] as const;
```

### キッズモード設定画面に「親のモードに戻る」ボタン追加

**背景:**
- 親が誤って自分のアカウントでキッズモードに入った場合、戻る手段がない
- 発生頻度は低いが、完全に閉じ込められてしまう

**実装:**
```typescript
// ViewModeContextを使用
const { selectedChildId, setSelectedChildId, setViewMode } = useViewMode();

// 親のモードに戻る関数
const handleBackToParentMode = async () => {
  setSelectedChildId(null);      // selectedChildIdをクリア
  await setViewMode('adult');    // 大人用モードに切り替え
  router.push('/');              // ホーム画面にリダイレクト
};

// UIボタン追加
<button onClick={handleBackToParentMode}>
  <LogOut size={20} />
  <span>おやの モード に もどる</span>
</button>
<p className="text-xs text-white/80 text-center mt-2">
  ※ おやが まちがえて きっずもーど に なった ときに つかってね
</p>
```

### データフロー（修正後）

**子供画面への遷移:**
```
親が設定画面で「子供の画面：すまほなしこ」をクリック
  ↓
ViewModeContext.setSelectedChildId(childId)
  ↓
localStorage.setItem('selectedChildId', childId)  ★ キー名統一
  ↓
ViewModeContext.setViewMode('kids')
  ↓
router.push('/') → KidsHomeが表示
  ↓
設定ボタンをクリック → /child-mode/settings
  ↓
ViewModeContextから selectedChildId を取得 ★ 修正後は正しく取得できる
  ↓
/api/profiles/${selectedChildId} でプロフィール取得
  ↓
real_name を優先的に表示 ★ 本名が表示される
```

### 表示ロジックの統一ルール

**スマホなし子供（代理管理メンバー）:**
1. 保存: `real_name` と `display_name` の両方に保存
2. 取得: `real_name` を最優先
3. 表示: `real_name || "登録なし"`（display_nameは無視）

**スマホあり子供（実メンバー）:**
1. 保存: `display_name`のみ（LINEから自動取得）
2. 取得: `display_name`
3. 表示: `display_name`

### UI/UXの改善

**「スマホなしの子供を追加」の明確化:**
- ボタンテキスト: 「👶 スマホなしの子供を追加」
- ダイアログタイトル: 「👶 スマホなしの子供を追加」
- 説明文追加: 「スマホやLINEアカウントを持っていない小さなお子様を登録します。親が代わりに管理できます。」

**招待コードとの区別:**
- 招待コードセクション: 「📱 お子様のスマホから参加」
- 追加ボタン: 「👶 スマホなしの子供を追加」
- アイコンで視覚的に区別

### トラブルシューティング

**問題: キッズモード設定画面で「子供IDが見つかりません」**
- 原因: localStorageのキー名不一致（`currentChildId` vs `selectedChildId`）
- 解決: ViewModeContextから直接`selectedChildId`を取得

**問題: 子供の名前が正しく表示されない**
- 原因: `display_name`を使用していた
- 解決: スマホなし子供は`real_name`を優先

**問題: 名前編集しても反映されない**
- 原因: `real_name`を更新していなかった
- 解決: 保存時に両方（`display_name`と`real_name`）を更新

### テスト確認項目

**スマホなし子供の追加:**
- [x] 「👶 スマホなしの子供を追加」ボタンが表示される
- [x] 名前と診察券番号を入力できる
- [x] 保存後、メンバー一覧に表示される
- [x] `real_name`と`display_name`の両方に保存される

**子供画面への切り替え:**
- [x] 設定画面で「子供の画面」ボタンをクリックできる
- [x] キッズホーム画面が表示される
- [x] `real_name`が正しく表示される（`real_name`がない場合は「登録なし」）

**キッズモード設定画面:**
- [x] 設定ボタンをタップして設定画面が開く
- [x] 「子供IDが見つかりません」エラーが出ない ★ 修正後
- [x] 名前と診察券番号を編集できる
- [x] 保存後、即座に反映される
- [x] 「おやの モード に もどる」ボタンで親画面に戻れる

**データ整合性:**
- [x] 家族管理画面で`real_name`が表示される
- [x] キッズホーム画面で`real_name`が表示される
- [x] キッズモード設定画面で`real_name`が表示・編集される
- [x] すべての画面で表示ロジックが統一されている

### ビルド確認

- ✅ TypeScript型チェック成功（`npx tsc --noEmit`）
- ✅ Production build成功（`npm run build`）
- データベーススキーマ変更なし
- 環境変数変更なし

### セキュリティ

- localStorageはブラウザ単位で管理（他人のアクセス不可）
- ViewModeContextで一元管理（データの一貫性保証）
- APIレイヤーで親の権限チェック（変更なし）

### 今後の注意事項

**localStorageキーの統一:**
- 必ず`selectedChildId`を使用
- `currentChildId`は使わない（削除済み）

**名前フィールドの使い分け:**
- スマホなし子供: `real_name`を使用
- スマホあり子供: `display_name`を使用
- 表示時は必ずロジックで分岐

**ViewModeContextの活用:**
- localStorageを直接操作しない
- ViewModeContextのAPIを使用して状態管理

### ドキュメント更新

- `Doc/90_実装履歴.md`: 本セクションを追加
- `Doc/70_子供画面切替機能仕様.md`: 技術仕様を更新予定

